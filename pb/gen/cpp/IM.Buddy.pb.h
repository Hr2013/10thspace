// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Buddy.proto

#ifndef PROTOBUF_IM_2eBuddy_2eproto__INCLUDED
#define PROTOBUF_IM_2eBuddy_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "IM.BaseDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace IM {
namespace Buddy {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_IM_2eBuddy_2eproto();
void protobuf_AssignDesc_IM_2eBuddy_2eproto();
void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

class IMRecentContactSessionReq;
class IMRecentContactSessionRsp;
class IMUserStatNotify;
class IMUsersInfoReq;
class IMUsersInfoRsp;
class IMRemoveSessionReq;
class IMRemoveSessionRsp;
class IMAllUserReq;
class IMAllUserRsp;
class IMUsersStatReq;
class IMUsersStatRsp;
class IMChangeAvatarReq;
class IMChangeAvatarRsp;
class IMPCLoginStatusNotify;
class IMRemoveSessionNotify;
class IMDepartmentReq;
class IMDepartmentRsp;
class IMAvatarChangedNotify;
class IMChangeSignInfoReq;
class IMChangeSignInfoRsp;
class IMSignInfoChangedNotify;
class IMSearchUserReq;
class IMSearchUserRsp;
class IMAddFriendReq;
class IMAddFriendRsp;
class IMAddFriendData;
class IMAddFriendReadDataAck;
class IMGetAddFriendDataReq;
class IMGetAddFriendDataRsp;
class IMAddFriendUnreadCntReq;
class IMAddFriendUnreadCntRsp;
class IMAgreeAddFriendReq;
class IMAgreeAddFriendRsp;
class IMFollowUserReq;
class IMFollowUserRsp;
class IMDelFriendReq;
class IMDelFriendRsp;
class IMDelFollowUserReq;
class IMDelFollowUserRsp;
class IMALLOnlineUserCntReq;
class IMALLOnlineUserCntRsp;
class IMUpdateUsersInfoReq;
class IMUpdateUsersInfoRsp;
class IMRecommendListReq;
class IMRecommendListRsp;

// ===================================================================

class IMRecentContactSessionReq : public ::google::protobuf::MessageLite {
 public:
  IMRecentContactSessionReq();
  virtual ~IMRecentContactSessionReq();

  IMRecentContactSessionReq(const IMRecentContactSessionReq& from);

  inline IMRecentContactSessionReq& operator=(const IMRecentContactSessionReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRecentContactSessionReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRecentContactSessionReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRecentContactSessionReq* other);

  // implements Message ----------------------------------------------

  IMRecentContactSessionReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRecentContactSessionReq& from);
  void MergeFrom(const IMRecentContactSessionReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRecentContactSessionReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRecentContactSessionReq* default_instance_;
};
// -------------------------------------------------------------------

class IMRecentContactSessionRsp : public ::google::protobuf::MessageLite {
 public:
  IMRecentContactSessionRsp();
  virtual ~IMRecentContactSessionRsp();

  IMRecentContactSessionRsp(const IMRecentContactSessionRsp& from);

  inline IMRecentContactSessionRsp& operator=(const IMRecentContactSessionRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRecentContactSessionRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRecentContactSessionRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRecentContactSessionRsp* other);

  // implements Message ----------------------------------------------

  IMRecentContactSessionRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRecentContactSessionRsp& from);
  void MergeFrom(const IMRecentContactSessionRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.ContactSessionInfo contact_session_list = 2;
  inline int contact_session_list_size() const;
  inline void clear_contact_session_list();
  static const int kContactSessionListFieldNumber = 2;
  inline const ::IM::BaseDefine::ContactSessionInfo& contact_session_list(int index) const;
  inline ::IM::BaseDefine::ContactSessionInfo* mutable_contact_session_list(int index);
  inline ::IM::BaseDefine::ContactSessionInfo* add_contact_session_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo >&
      contact_session_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo >*
      mutable_contact_session_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRecentContactSessionRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo > contact_session_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRecentContactSessionRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMUserStatNotify : public ::google::protobuf::MessageLite {
 public:
  IMUserStatNotify();
  virtual ~IMUserStatNotify();

  IMUserStatNotify(const IMUserStatNotify& from);

  inline IMUserStatNotify& operator=(const IMUserStatNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUserStatNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUserStatNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUserStatNotify* other);

  // implements Message ----------------------------------------------

  IMUserStatNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUserStatNotify& from);
  void MergeFrom(const IMUserStatNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .IM.BaseDefine.UserStat user_stat = 1;
  inline bool has_user_stat() const;
  inline void clear_user_stat();
  static const int kUserStatFieldNumber = 1;
  inline const ::IM::BaseDefine::UserStat& user_stat() const;
  inline ::IM::BaseDefine::UserStat* mutable_user_stat();
  inline ::IM::BaseDefine::UserStat* release_user_stat();
  inline void set_allocated_user_stat(::IM::BaseDefine::UserStat* user_stat);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUserStatNotify)
 private:
  inline void set_has_user_stat();
  inline void clear_has_user_stat();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::IM::BaseDefine::UserStat* user_stat_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUserStatNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMUsersInfoReq : public ::google::protobuf::MessageLite {
 public:
  IMUsersInfoReq();
  virtual ~IMUsersInfoReq();

  IMUsersInfoReq(const IMUsersInfoReq& from);

  inline IMUsersInfoReq& operator=(const IMUsersInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUsersInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUsersInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUsersInfoReq* other);

  // implements Message ----------------------------------------------

  IMUsersInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUsersInfoReq& from);
  void MergeFrom(const IMUsersInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated uint32 user_id_list = 2;
  inline int user_id_list_size() const;
  inline void clear_user_id_list();
  static const int kUserIdListFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id_list(int index) const;
  inline void set_user_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_user_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      user_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_user_id_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUsersInfoReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > user_id_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUsersInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class IMUsersInfoRsp : public ::google::protobuf::MessageLite {
 public:
  IMUsersInfoRsp();
  virtual ~IMUsersInfoRsp();

  IMUsersInfoRsp(const IMUsersInfoRsp& from);

  inline IMUsersInfoRsp& operator=(const IMUsersInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUsersInfoRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUsersInfoRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUsersInfoRsp* other);

  // implements Message ----------------------------------------------

  IMUsersInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUsersInfoRsp& from);
  void MergeFrom(const IMUsersInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.UserInfo user_info_list = 2;
  inline int user_info_list_size() const;
  inline void clear_user_info_list();
  static const int kUserInfoListFieldNumber = 2;
  inline const ::IM::BaseDefine::UserInfo& user_info_list(int index) const;
  inline ::IM::BaseDefine::UserInfo* mutable_user_info_list(int index);
  inline ::IM::BaseDefine::UserInfo* add_user_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
      user_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
      mutable_user_info_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUsersInfoRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo > user_info_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUsersInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMRemoveSessionReq : public ::google::protobuf::MessageLite {
 public:
  IMRemoveSessionReq();
  virtual ~IMRemoveSessionReq();

  IMRemoveSessionReq(const IMRemoveSessionReq& from);

  inline IMRemoveSessionReq& operator=(const IMRemoveSessionReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRemoveSessionReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRemoveSessionReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRemoveSessionReq* other);

  // implements Message ----------------------------------------------

  IMRemoveSessionReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRemoveSessionReq& from);
  void MergeFrom(const IMRemoveSessionReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SessionType session_type = 2;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 2;
  inline ::IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(::IM::BaseDefine::SessionType value);

  // required uint32 session_id = 3;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRemoveSessionReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  int session_type_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 session_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRemoveSessionReq* default_instance_;
};
// -------------------------------------------------------------------

class IMRemoveSessionRsp : public ::google::protobuf::MessageLite {
 public:
  IMRemoveSessionRsp();
  virtual ~IMRemoveSessionRsp();

  IMRemoveSessionRsp(const IMRemoveSessionRsp& from);

  inline IMRemoveSessionRsp& operator=(const IMRemoveSessionRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRemoveSessionRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRemoveSessionRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRemoveSessionRsp* other);

  // implements Message ----------------------------------------------

  IMRemoveSessionRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRemoveSessionRsp& from);
  void MergeFrom(const IMRemoveSessionRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SessionType session_type = 3;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 3;
  inline ::IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(::IM::BaseDefine::SessionType value);

  // required uint32 session_id = 4;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 4;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRemoveSessionRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  int session_type_;
  ::google::protobuf::uint32 session_id_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRemoveSessionRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMAllUserReq : public ::google::protobuf::MessageLite {
 public:
  IMAllUserReq();
  virtual ~IMAllUserReq();

  IMAllUserReq(const IMAllUserReq& from);

  inline IMAllUserReq& operator=(const IMAllUserReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMAllUserReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMAllUserReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMAllUserReq* other);

  // implements Message ----------------------------------------------

  IMAllUserReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAllUserReq& from);
  void MergeFrom(const IMAllUserReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAllUserReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMAllUserReq* default_instance_;
};
// -------------------------------------------------------------------

class IMAllUserRsp : public ::google::protobuf::MessageLite {
 public:
  IMAllUserRsp();
  virtual ~IMAllUserRsp();

  IMAllUserRsp(const IMAllUserRsp& from);

  inline IMAllUserRsp& operator=(const IMAllUserRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMAllUserRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMAllUserRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMAllUserRsp* other);

  // implements Message ----------------------------------------------

  IMAllUserRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAllUserRsp& from);
  void MergeFrom(const IMAllUserRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.UserInfo user_list = 3;
  inline int user_list_size() const;
  inline void clear_user_list();
  static const int kUserListFieldNumber = 3;
  inline const ::IM::BaseDefine::UserInfo& user_list(int index) const;
  inline ::IM::BaseDefine::UserInfo* mutable_user_list(int index);
  inline ::IM::BaseDefine::UserInfo* add_user_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
      user_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
      mutable_user_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAllUserRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo > user_list_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMAllUserRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMUsersStatReq : public ::google::protobuf::MessageLite {
 public:
  IMUsersStatReq();
  virtual ~IMUsersStatReq();

  IMUsersStatReq(const IMUsersStatReq& from);

  inline IMUsersStatReq& operator=(const IMUsersStatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUsersStatReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUsersStatReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUsersStatReq* other);

  // implements Message ----------------------------------------------

  IMUsersStatReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUsersStatReq& from);
  void MergeFrom(const IMUsersStatReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated uint32 user_id_list = 2;
  inline int user_id_list_size() const;
  inline void clear_user_id_list();
  static const int kUserIdListFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id_list(int index) const;
  inline void set_user_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_user_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      user_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_user_id_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUsersStatReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > user_id_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUsersStatReq* default_instance_;
};
// -------------------------------------------------------------------

class IMUsersStatRsp : public ::google::protobuf::MessageLite {
 public:
  IMUsersStatRsp();
  virtual ~IMUsersStatRsp();

  IMUsersStatRsp(const IMUsersStatRsp& from);

  inline IMUsersStatRsp& operator=(const IMUsersStatRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUsersStatRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUsersStatRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUsersStatRsp* other);

  // implements Message ----------------------------------------------

  IMUsersStatRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUsersStatRsp& from);
  void MergeFrom(const IMUsersStatRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.UserStat user_stat_list = 2;
  inline int user_stat_list_size() const;
  inline void clear_user_stat_list();
  static const int kUserStatListFieldNumber = 2;
  inline const ::IM::BaseDefine::UserStat& user_stat_list(int index) const;
  inline ::IM::BaseDefine::UserStat* mutable_user_stat_list(int index);
  inline ::IM::BaseDefine::UserStat* add_user_stat_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat >&
      user_stat_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat >*
      mutable_user_stat_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUsersStatRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat > user_stat_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUsersStatRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMChangeAvatarReq : public ::google::protobuf::MessageLite {
 public:
  IMChangeAvatarReq();
  virtual ~IMChangeAvatarReq();

  IMChangeAvatarReq(const IMChangeAvatarReq& from);

  inline IMChangeAvatarReq& operator=(const IMChangeAvatarReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMChangeAvatarReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMChangeAvatarReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMChangeAvatarReq* other);

  // implements Message ----------------------------------------------

  IMChangeAvatarReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMChangeAvatarReq& from);
  void MergeFrom(const IMChangeAvatarReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required string avatar_url = 2;
  inline bool has_avatar_url() const;
  inline void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 2;
  inline const ::std::string& avatar_url() const;
  inline void set_avatar_url(const ::std::string& value);
  inline void set_avatar_url(const char* value);
  inline void set_avatar_url(const char* value, size_t size);
  inline ::std::string* mutable_avatar_url();
  inline ::std::string* release_avatar_url();
  inline void set_allocated_avatar_url(::std::string* avatar_url);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMChangeAvatarReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_avatar_url();
  inline void clear_has_avatar_url();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* avatar_url_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMChangeAvatarReq* default_instance_;
};
// -------------------------------------------------------------------

class IMChangeAvatarRsp : public ::google::protobuf::MessageLite {
 public:
  IMChangeAvatarRsp();
  virtual ~IMChangeAvatarRsp();

  IMChangeAvatarRsp(const IMChangeAvatarRsp& from);

  inline IMChangeAvatarRsp& operator=(const IMChangeAvatarRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMChangeAvatarRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMChangeAvatarRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMChangeAvatarRsp* other);

  // implements Message ----------------------------------------------

  IMChangeAvatarRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMChangeAvatarRsp& from);
  void MergeFrom(const IMChangeAvatarRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMChangeAvatarRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMChangeAvatarRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMPCLoginStatusNotify : public ::google::protobuf::MessageLite {
 public:
  IMPCLoginStatusNotify();
  virtual ~IMPCLoginStatusNotify();

  IMPCLoginStatusNotify(const IMPCLoginStatusNotify& from);

  inline IMPCLoginStatusNotify& operator=(const IMPCLoginStatusNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMPCLoginStatusNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMPCLoginStatusNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMPCLoginStatusNotify* other);

  // implements Message ----------------------------------------------

  IMPCLoginStatusNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMPCLoginStatusNotify& from);
  void MergeFrom(const IMPCLoginStatusNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.UserStatType login_stat = 2;
  inline bool has_login_stat() const;
  inline void clear_login_stat();
  static const int kLoginStatFieldNumber = 2;
  inline ::IM::BaseDefine::UserStatType login_stat() const;
  inline void set_login_stat(::IM::BaseDefine::UserStatType value);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMPCLoginStatusNotify)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_login_stat();
  inline void clear_has_login_stat();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  int login_stat_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMPCLoginStatusNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMRemoveSessionNotify : public ::google::protobuf::MessageLite {
 public:
  IMRemoveSessionNotify();
  virtual ~IMRemoveSessionNotify();

  IMRemoveSessionNotify(const IMRemoveSessionNotify& from);

  inline IMRemoveSessionNotify& operator=(const IMRemoveSessionNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRemoveSessionNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRemoveSessionNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRemoveSessionNotify* other);

  // implements Message ----------------------------------------------

  IMRemoveSessionNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRemoveSessionNotify& from);
  void MergeFrom(const IMRemoveSessionNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SessionType session_type = 2;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 2;
  inline ::IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(::IM::BaseDefine::SessionType value);

  // required uint32 session_id = 3;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRemoveSessionNotify)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_session_id();
  inline void clear_has_session_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  int session_type_;
  ::google::protobuf::uint32 session_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRemoveSessionNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMDepartmentReq : public ::google::protobuf::MessageLite {
 public:
  IMDepartmentReq();
  virtual ~IMDepartmentReq();

  IMDepartmentReq(const IMDepartmentReq& from);

  inline IMDepartmentReq& operator=(const IMDepartmentReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMDepartmentReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMDepartmentReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMDepartmentReq* other);

  // implements Message ----------------------------------------------

  IMDepartmentReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMDepartmentReq& from);
  void MergeFrom(const IMDepartmentReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMDepartmentReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMDepartmentReq* default_instance_;
};
// -------------------------------------------------------------------

class IMDepartmentRsp : public ::google::protobuf::MessageLite {
 public:
  IMDepartmentRsp();
  virtual ~IMDepartmentRsp();

  IMDepartmentRsp(const IMDepartmentRsp& from);

  inline IMDepartmentRsp& operator=(const IMDepartmentRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMDepartmentRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMDepartmentRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMDepartmentRsp* other);

  // implements Message ----------------------------------------------

  IMDepartmentRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMDepartmentRsp& from);
  void MergeFrom(const IMDepartmentRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.DepartInfo dept_list = 3;
  inline int dept_list_size() const;
  inline void clear_dept_list();
  static const int kDeptListFieldNumber = 3;
  inline const ::IM::BaseDefine::DepartInfo& dept_list(int index) const;
  inline ::IM::BaseDefine::DepartInfo* mutable_dept_list(int index);
  inline ::IM::BaseDefine::DepartInfo* add_dept_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo >&
      dept_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo >*
      mutable_dept_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMDepartmentRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo > dept_list_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMDepartmentRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMAvatarChangedNotify : public ::google::protobuf::MessageLite {
 public:
  IMAvatarChangedNotify();
  virtual ~IMAvatarChangedNotify();

  IMAvatarChangedNotify(const IMAvatarChangedNotify& from);

  inline IMAvatarChangedNotify& operator=(const IMAvatarChangedNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMAvatarChangedNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMAvatarChangedNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMAvatarChangedNotify* other);

  // implements Message ----------------------------------------------

  IMAvatarChangedNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAvatarChangedNotify& from);
  void MergeFrom(const IMAvatarChangedNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 changed_user_id = 1;
  inline bool has_changed_user_id() const;
  inline void clear_changed_user_id();
  static const int kChangedUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 changed_user_id() const;
  inline void set_changed_user_id(::google::protobuf::uint32 value);

  // required string avatar_url = 2;
  inline bool has_avatar_url() const;
  inline void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 2;
  inline const ::std::string& avatar_url() const;
  inline void set_avatar_url(const ::std::string& value);
  inline void set_avatar_url(const char* value);
  inline void set_avatar_url(const char* value, size_t size);
  inline ::std::string* mutable_avatar_url();
  inline ::std::string* release_avatar_url();
  inline void set_allocated_avatar_url(::std::string* avatar_url);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAvatarChangedNotify)
 private:
  inline void set_has_changed_user_id();
  inline void clear_has_changed_user_id();
  inline void set_has_avatar_url();
  inline void clear_has_avatar_url();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* avatar_url_;
  ::google::protobuf::uint32 changed_user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMAvatarChangedNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMChangeSignInfoReq : public ::google::protobuf::MessageLite {
 public:
  IMChangeSignInfoReq();
  virtual ~IMChangeSignInfoReq();

  IMChangeSignInfoReq(const IMChangeSignInfoReq& from);

  inline IMChangeSignInfoReq& operator=(const IMChangeSignInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMChangeSignInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMChangeSignInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMChangeSignInfoReq* other);

  // implements Message ----------------------------------------------

  IMChangeSignInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMChangeSignInfoReq& from);
  void MergeFrom(const IMChangeSignInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required string sign_info = 2;
  inline bool has_sign_info() const;
  inline void clear_sign_info();
  static const int kSignInfoFieldNumber = 2;
  inline const ::std::string& sign_info() const;
  inline void set_sign_info(const ::std::string& value);
  inline void set_sign_info(const char* value);
  inline void set_sign_info(const char* value, size_t size);
  inline ::std::string* mutable_sign_info();
  inline ::std::string* release_sign_info();
  inline void set_allocated_sign_info(::std::string* sign_info);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMChangeSignInfoReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_sign_info();
  inline void clear_has_sign_info();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* sign_info_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMChangeSignInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class IMChangeSignInfoRsp : public ::google::protobuf::MessageLite {
 public:
  IMChangeSignInfoRsp();
  virtual ~IMChangeSignInfoRsp();

  IMChangeSignInfoRsp(const IMChangeSignInfoRsp& from);

  inline IMChangeSignInfoRsp& operator=(const IMChangeSignInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMChangeSignInfoRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMChangeSignInfoRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMChangeSignInfoRsp* other);

  // implements Message ----------------------------------------------

  IMChangeSignInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMChangeSignInfoRsp& from);
  void MergeFrom(const IMChangeSignInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional string sign_info = 3;
  inline bool has_sign_info() const;
  inline void clear_sign_info();
  static const int kSignInfoFieldNumber = 3;
  inline const ::std::string& sign_info() const;
  inline void set_sign_info(const ::std::string& value);
  inline void set_sign_info(const char* value);
  inline void set_sign_info(const char* value, size_t size);
  inline ::std::string* mutable_sign_info();
  inline ::std::string* release_sign_info();
  inline void set_allocated_sign_info(::std::string* sign_info);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMChangeSignInfoRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_sign_info();
  inline void clear_has_sign_info();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* sign_info_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMChangeSignInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMSignInfoChangedNotify : public ::google::protobuf::MessageLite {
 public:
  IMSignInfoChangedNotify();
  virtual ~IMSignInfoChangedNotify();

  IMSignInfoChangedNotify(const IMSignInfoChangedNotify& from);

  inline IMSignInfoChangedNotify& operator=(const IMSignInfoChangedNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMSignInfoChangedNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMSignInfoChangedNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMSignInfoChangedNotify* other);

  // implements Message ----------------------------------------------

  IMSignInfoChangedNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMSignInfoChangedNotify& from);
  void MergeFrom(const IMSignInfoChangedNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 changed_user_id = 1;
  inline bool has_changed_user_id() const;
  inline void clear_changed_user_id();
  static const int kChangedUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 changed_user_id() const;
  inline void set_changed_user_id(::google::protobuf::uint32 value);

  // required string sign_info = 2;
  inline bool has_sign_info() const;
  inline void clear_sign_info();
  static const int kSignInfoFieldNumber = 2;
  inline const ::std::string& sign_info() const;
  inline void set_sign_info(const ::std::string& value);
  inline void set_sign_info(const char* value);
  inline void set_sign_info(const char* value, size_t size);
  inline ::std::string* mutable_sign_info();
  inline ::std::string* release_sign_info();
  inline void set_allocated_sign_info(::std::string* sign_info);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMSignInfoChangedNotify)
 private:
  inline void set_has_changed_user_id();
  inline void clear_has_changed_user_id();
  inline void set_has_sign_info();
  inline void clear_has_sign_info();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* sign_info_;
  ::google::protobuf::uint32 changed_user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMSignInfoChangedNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMSearchUserReq : public ::google::protobuf::MessageLite {
 public:
  IMSearchUserReq();
  virtual ~IMSearchUserReq();

  IMSearchUserReq(const IMSearchUserReq& from);

  inline IMSearchUserReq& operator=(const IMSearchUserReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMSearchUserReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMSearchUserReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMSearchUserReq* other);

  // implements Message ----------------------------------------------

  IMSearchUserReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMSearchUserReq& from);
  void MergeFrom(const IMSearchUserReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required string search_user_name = 2;
  inline bool has_search_user_name() const;
  inline void clear_search_user_name();
  static const int kSearchUserNameFieldNumber = 2;
  inline const ::std::string& search_user_name() const;
  inline void set_search_user_name(const ::std::string& value);
  inline void set_search_user_name(const char* value);
  inline void set_search_user_name(const char* value, size_t size);
  inline ::std::string* mutable_search_user_name();
  inline ::std::string* release_search_user_name();
  inline void set_allocated_search_user_name(::std::string* search_user_name);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMSearchUserReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_search_user_name();
  inline void clear_has_search_user_name();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* search_user_name_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMSearchUserReq* default_instance_;
};
// -------------------------------------------------------------------

class IMSearchUserRsp : public ::google::protobuf::MessageLite {
 public:
  IMSearchUserRsp();
  virtual ~IMSearchUserRsp();

  IMSearchUserRsp(const IMSearchUserRsp& from);

  inline IMSearchUserRsp& operator=(const IMSearchUserRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMSearchUserRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMSearchUserRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMSearchUserRsp* other);

  // implements Message ----------------------------------------------

  IMSearchUserRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMSearchUserRsp& from);
  void MergeFrom(const IMSearchUserRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.UserInfo search_user_list = 2;
  inline int search_user_list_size() const;
  inline void clear_search_user_list();
  static const int kSearchUserListFieldNumber = 2;
  inline const ::IM::BaseDefine::UserInfo& search_user_list(int index) const;
  inline ::IM::BaseDefine::UserInfo* mutable_search_user_list(int index);
  inline ::IM::BaseDefine::UserInfo* add_search_user_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
      search_user_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
      mutable_search_user_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMSearchUserRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo > search_user_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMSearchUserRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMAddFriendReq : public ::google::protobuf::MessageLite {
 public:
  IMAddFriendReq();
  virtual ~IMAddFriendReq();

  IMAddFriendReq(const IMAddFriendReq& from);

  inline IMAddFriendReq& operator=(const IMAddFriendReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMAddFriendReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMAddFriendReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMAddFriendReq* other);

  // implements Message ----------------------------------------------

  IMAddFriendReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAddFriendReq& from);
  void MergeFrom(const IMAddFriendReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 friend_id = 2;
  inline bool has_friend_id() const;
  inline void clear_friend_id();
  static const int kFriendIdFieldNumber = 2;
  inline ::google::protobuf::uint32 friend_id() const;
  inline void set_friend_id(::google::protobuf::uint32 value);

  // optional bytes addition_msg = 3;
  inline bool has_addition_msg() const;
  inline void clear_addition_msg();
  static const int kAdditionMsgFieldNumber = 3;
  inline const ::std::string& addition_msg() const;
  inline void set_addition_msg(const ::std::string& value);
  inline void set_addition_msg(const char* value);
  inline void set_addition_msg(const void* value, size_t size);
  inline ::std::string* mutable_addition_msg();
  inline ::std::string* release_addition_msg();
  inline void set_allocated_addition_msg(::std::string* addition_msg);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAddFriendReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_friend_id();
  inline void clear_has_friend_id();
  inline void set_has_addition_msg();
  inline void clear_has_addition_msg();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 friend_id_;
  ::std::string* addition_msg_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMAddFriendReq* default_instance_;
};
// -------------------------------------------------------------------

class IMAddFriendRsp : public ::google::protobuf::MessageLite {
 public:
  IMAddFriendRsp();
  virtual ~IMAddFriendRsp();

  IMAddFriendRsp(const IMAddFriendRsp& from);

  inline IMAddFriendRsp& operator=(const IMAddFriendRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMAddFriendRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMAddFriendRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMAddFriendRsp* other);

  // implements Message ----------------------------------------------

  IMAddFriendRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAddFriendRsp& from);
  void MergeFrom(const IMAddFriendRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 friend_id = 2;
  inline bool has_friend_id() const;
  inline void clear_friend_id();
  static const int kFriendIdFieldNumber = 2;
  inline ::google::protobuf::uint32 friend_id() const;
  inline void set_friend_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 3;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 3;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional bytes add_friend_data = 4;
  inline bool has_add_friend_data() const;
  inline void clear_add_friend_data();
  static const int kAddFriendDataFieldNumber = 4;
  inline const ::std::string& add_friend_data() const;
  inline void set_add_friend_data(const ::std::string& value);
  inline void set_add_friend_data(const char* value);
  inline void set_add_friend_data(const void* value, size_t size);
  inline ::std::string* mutable_add_friend_data();
  inline ::std::string* release_add_friend_data();
  inline void set_allocated_add_friend_data(::std::string* add_friend_data);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAddFriendRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_friend_id();
  inline void clear_has_friend_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_add_friend_data();
  inline void clear_has_add_friend_data();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 friend_id_;
  ::std::string* add_friend_data_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 result_code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMAddFriendRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMAddFriendData : public ::google::protobuf::MessageLite {
 public:
  IMAddFriendData();
  virtual ~IMAddFriendData();

  IMAddFriendData(const IMAddFriendData& from);

  inline IMAddFriendData& operator=(const IMAddFriendData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMAddFriendData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMAddFriendData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMAddFriendData* other);

  // implements Message ----------------------------------------------

  IMAddFriendData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAddFriendData& from);
  void MergeFrom(const IMAddFriendData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 friend_id = 2;
  inline bool has_friend_id() const;
  inline void clear_friend_id();
  static const int kFriendIdFieldNumber = 2;
  inline ::google::protobuf::uint32 friend_id() const;
  inline void set_friend_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SystemMsgType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::IM::BaseDefine::SystemMsgType type() const;
  inline void set_type(::IM::BaseDefine::SystemMsgType value);

  // required bytes add_friend_data = 5;
  inline bool has_add_friend_data() const;
  inline void clear_add_friend_data();
  static const int kAddFriendDataFieldNumber = 5;
  inline const ::std::string& add_friend_data() const;
  inline void set_add_friend_data(const ::std::string& value);
  inline void set_add_friend_data(const char* value);
  inline void set_add_friend_data(const void* value, size_t size);
  inline ::std::string* mutable_add_friend_data();
  inline ::std::string* release_add_friend_data();
  inline void set_allocated_add_friend_data(::std::string* add_friend_data);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAddFriendData)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_friend_id();
  inline void clear_has_friend_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_add_friend_data();
  inline void clear_has_add_friend_data();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 friend_id_;
  ::std::string* add_friend_data_;
  ::std::string* attach_data_;
  int type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMAddFriendData* default_instance_;
};
// -------------------------------------------------------------------

class IMAddFriendReadDataAck : public ::google::protobuf::MessageLite {
 public:
  IMAddFriendReadDataAck();
  virtual ~IMAddFriendReadDataAck();

  IMAddFriendReadDataAck(const IMAddFriendReadDataAck& from);

  inline IMAddFriendReadDataAck& operator=(const IMAddFriendReadDataAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMAddFriendReadDataAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMAddFriendReadDataAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMAddFriendReadDataAck* other);

  // implements Message ----------------------------------------------

  IMAddFriendReadDataAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAddFriendReadDataAck& from);
  void MergeFrom(const IMAddFriendReadDataAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAddFriendReadDataAck)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMAddFriendReadDataAck* default_instance_;
};
// -------------------------------------------------------------------

class IMGetAddFriendDataReq : public ::google::protobuf::MessageLite {
 public:
  IMGetAddFriendDataReq();
  virtual ~IMGetAddFriendDataReq();

  IMGetAddFriendDataReq(const IMGetAddFriendDataReq& from);

  inline IMGetAddFriendDataReq& operator=(const IMGetAddFriendDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMGetAddFriendDataReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMGetAddFriendDataReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMGetAddFriendDataReq* other);

  // implements Message ----------------------------------------------

  IMGetAddFriendDataReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMGetAddFriendDataReq& from);
  void MergeFrom(const IMGetAddFriendDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 msg_cnt = 2;
  inline bool has_msg_cnt() const;
  inline void clear_msg_cnt();
  static const int kMsgCntFieldNumber = 2;
  inline ::google::protobuf::uint32 msg_cnt() const;
  inline void set_msg_cnt(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMGetAddFriendDataReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_msg_cnt();
  inline void clear_has_msg_cnt();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 msg_cnt_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMGetAddFriendDataReq* default_instance_;
};
// -------------------------------------------------------------------

class IMGetAddFriendDataRsp : public ::google::protobuf::MessageLite {
 public:
  IMGetAddFriendDataRsp();
  virtual ~IMGetAddFriendDataRsp();

  IMGetAddFriendDataRsp(const IMGetAddFriendDataRsp& from);

  inline IMGetAddFriendDataRsp& operator=(const IMGetAddFriendDataRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMGetAddFriendDataRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMGetAddFriendDataRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMGetAddFriendDataRsp* other);

  // implements Message ----------------------------------------------

  IMGetAddFriendDataRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMGetAddFriendDataRsp& from);
  void MergeFrom(const IMGetAddFriendDataRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated .IM.Buddy.IMAddFriendData data_list = 2;
  inline int data_list_size() const;
  inline void clear_data_list();
  static const int kDataListFieldNumber = 2;
  inline const ::IM::Buddy::IMAddFriendData& data_list(int index) const;
  inline ::IM::Buddy::IMAddFriendData* mutable_data_list(int index);
  inline ::IM::Buddy::IMAddFriendData* add_data_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::IMAddFriendData >&
      data_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::IMAddFriendData >*
      mutable_data_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMGetAddFriendDataRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::Buddy::IMAddFriendData > data_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMGetAddFriendDataRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMAddFriendUnreadCntReq : public ::google::protobuf::MessageLite {
 public:
  IMAddFriendUnreadCntReq();
  virtual ~IMAddFriendUnreadCntReq();

  IMAddFriendUnreadCntReq(const IMAddFriendUnreadCntReq& from);

  inline IMAddFriendUnreadCntReq& operator=(const IMAddFriendUnreadCntReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMAddFriendUnreadCntReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMAddFriendUnreadCntReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMAddFriendUnreadCntReq* other);

  // implements Message ----------------------------------------------

  IMAddFriendUnreadCntReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAddFriendUnreadCntReq& from);
  void MergeFrom(const IMAddFriendUnreadCntReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAddFriendUnreadCntReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMAddFriendUnreadCntReq* default_instance_;
};
// -------------------------------------------------------------------

class IMAddFriendUnreadCntRsp : public ::google::protobuf::MessageLite {
 public:
  IMAddFriendUnreadCntRsp();
  virtual ~IMAddFriendUnreadCntRsp();

  IMAddFriendUnreadCntRsp(const IMAddFriendUnreadCntRsp& from);

  inline IMAddFriendUnreadCntRsp& operator=(const IMAddFriendUnreadCntRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMAddFriendUnreadCntRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMAddFriendUnreadCntRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMAddFriendUnreadCntRsp* other);

  // implements Message ----------------------------------------------

  IMAddFriendUnreadCntRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAddFriendUnreadCntRsp& from);
  void MergeFrom(const IMAddFriendUnreadCntRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 unread_cnt = 2;
  inline bool has_unread_cnt() const;
  inline void clear_unread_cnt();
  static const int kUnreadCntFieldNumber = 2;
  inline ::google::protobuf::uint32 unread_cnt() const;
  inline void set_unread_cnt(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAddFriendUnreadCntRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_unread_cnt();
  inline void clear_has_unread_cnt();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 unread_cnt_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMAddFriendUnreadCntRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMAgreeAddFriendReq : public ::google::protobuf::MessageLite {
 public:
  IMAgreeAddFriendReq();
  virtual ~IMAgreeAddFriendReq();

  IMAgreeAddFriendReq(const IMAgreeAddFriendReq& from);

  inline IMAgreeAddFriendReq& operator=(const IMAgreeAddFriendReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMAgreeAddFriendReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMAgreeAddFriendReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMAgreeAddFriendReq* other);

  // implements Message ----------------------------------------------

  IMAgreeAddFriendReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAgreeAddFriendReq& from);
  void MergeFrom(const IMAgreeAddFriendReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 friend_id = 2;
  inline bool has_friend_id() const;
  inline void clear_friend_id();
  static const int kFriendIdFieldNumber = 2;
  inline ::google::protobuf::uint32 friend_id() const;
  inline void set_friend_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SystemMsgType agree = 3;
  inline bool has_agree() const;
  inline void clear_agree();
  static const int kAgreeFieldNumber = 3;
  inline ::IM::BaseDefine::SystemMsgType agree() const;
  inline void set_agree(::IM::BaseDefine::SystemMsgType value);

  // optional bytes addition_msg = 4;
  inline bool has_addition_msg() const;
  inline void clear_addition_msg();
  static const int kAdditionMsgFieldNumber = 4;
  inline const ::std::string& addition_msg() const;
  inline void set_addition_msg(const ::std::string& value);
  inline void set_addition_msg(const char* value);
  inline void set_addition_msg(const void* value, size_t size);
  inline ::std::string* mutable_addition_msg();
  inline ::std::string* release_addition_msg();
  inline void set_allocated_addition_msg(::std::string* addition_msg);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAgreeAddFriendReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_friend_id();
  inline void clear_has_friend_id();
  inline void set_has_agree();
  inline void clear_has_agree();
  inline void set_has_addition_msg();
  inline void clear_has_addition_msg();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 friend_id_;
  ::std::string* addition_msg_;
  ::std::string* attach_data_;
  int agree_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMAgreeAddFriendReq* default_instance_;
};
// -------------------------------------------------------------------

class IMAgreeAddFriendRsp : public ::google::protobuf::MessageLite {
 public:
  IMAgreeAddFriendRsp();
  virtual ~IMAgreeAddFriendRsp();

  IMAgreeAddFriendRsp(const IMAgreeAddFriendRsp& from);

  inline IMAgreeAddFriendRsp& operator=(const IMAgreeAddFriendRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMAgreeAddFriendRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMAgreeAddFriendRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMAgreeAddFriendRsp* other);

  // implements Message ----------------------------------------------

  IMAgreeAddFriendRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAgreeAddFriendRsp& from);
  void MergeFrom(const IMAgreeAddFriendRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 friend_id = 2;
  inline bool has_friend_id() const;
  inline void clear_friend_id();
  static const int kFriendIdFieldNumber = 2;
  inline ::google::protobuf::uint32 friend_id() const;
  inline void set_friend_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SystemMsgType agree = 3;
  inline bool has_agree() const;
  inline void clear_agree();
  static const int kAgreeFieldNumber = 3;
  inline ::IM::BaseDefine::SystemMsgType agree() const;
  inline void set_agree(::IM::BaseDefine::SystemMsgType value);

  // required uint32 result_code = 4;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 4;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional bytes agree_friend_data = 5;
  inline bool has_agree_friend_data() const;
  inline void clear_agree_friend_data();
  static const int kAgreeFriendDataFieldNumber = 5;
  inline const ::std::string& agree_friend_data() const;
  inline void set_agree_friend_data(const ::std::string& value);
  inline void set_agree_friend_data(const char* value);
  inline void set_agree_friend_data(const void* value, size_t size);
  inline ::std::string* mutable_agree_friend_data();
  inline ::std::string* release_agree_friend_data();
  inline void set_allocated_agree_friend_data(::std::string* agree_friend_data);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAgreeAddFriendRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_friend_id();
  inline void clear_has_friend_id();
  inline void set_has_agree();
  inline void clear_has_agree();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_agree_friend_data();
  inline void clear_has_agree_friend_data();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 friend_id_;
  int agree_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* agree_friend_data_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMAgreeAddFriendRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMFollowUserReq : public ::google::protobuf::MessageLite {
 public:
  IMFollowUserReq();
  virtual ~IMFollowUserReq();

  IMFollowUserReq(const IMFollowUserReq& from);

  inline IMFollowUserReq& operator=(const IMFollowUserReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMFollowUserReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMFollowUserReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMFollowUserReq* other);

  // implements Message ----------------------------------------------

  IMFollowUserReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFollowUserReq& from);
  void MergeFrom(const IMFollowUserReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 friend_id = 2;
  inline bool has_friend_id() const;
  inline void clear_friend_id();
  static const int kFriendIdFieldNumber = 2;
  inline ::google::protobuf::uint32 friend_id() const;
  inline void set_friend_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMFollowUserReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_friend_id();
  inline void clear_has_friend_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 friend_id_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMFollowUserReq* default_instance_;
};
// -------------------------------------------------------------------

class IMFollowUserRsp : public ::google::protobuf::MessageLite {
 public:
  IMFollowUserRsp();
  virtual ~IMFollowUserRsp();

  IMFollowUserRsp(const IMFollowUserRsp& from);

  inline IMFollowUserRsp& operator=(const IMFollowUserRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMFollowUserRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMFollowUserRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMFollowUserRsp* other);

  // implements Message ----------------------------------------------

  IMFollowUserRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFollowUserRsp& from);
  void MergeFrom(const IMFollowUserRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMFollowUserRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMFollowUserRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMDelFriendReq : public ::google::protobuf::MessageLite {
 public:
  IMDelFriendReq();
  virtual ~IMDelFriendReq();

  IMDelFriendReq(const IMDelFriendReq& from);

  inline IMDelFriendReq& operator=(const IMDelFriendReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMDelFriendReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMDelFriendReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMDelFriendReq* other);

  // implements Message ----------------------------------------------

  IMDelFriendReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMDelFriendReq& from);
  void MergeFrom(const IMDelFriendReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 friend_id = 2;
  inline bool has_friend_id() const;
  inline void clear_friend_id();
  static const int kFriendIdFieldNumber = 2;
  inline ::google::protobuf::uint32 friend_id() const;
  inline void set_friend_id(::google::protobuf::uint32 value);

  // optional bytes addition_msg = 3;
  inline bool has_addition_msg() const;
  inline void clear_addition_msg();
  static const int kAdditionMsgFieldNumber = 3;
  inline const ::std::string& addition_msg() const;
  inline void set_addition_msg(const ::std::string& value);
  inline void set_addition_msg(const char* value);
  inline void set_addition_msg(const void* value, size_t size);
  inline ::std::string* mutable_addition_msg();
  inline ::std::string* release_addition_msg();
  inline void set_allocated_addition_msg(::std::string* addition_msg);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMDelFriendReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_friend_id();
  inline void clear_has_friend_id();
  inline void set_has_addition_msg();
  inline void clear_has_addition_msg();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 friend_id_;
  ::std::string* addition_msg_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMDelFriendReq* default_instance_;
};
// -------------------------------------------------------------------

class IMDelFriendRsp : public ::google::protobuf::MessageLite {
 public:
  IMDelFriendRsp();
  virtual ~IMDelFriendRsp();

  IMDelFriendRsp(const IMDelFriendRsp& from);

  inline IMDelFriendRsp& operator=(const IMDelFriendRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMDelFriendRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMDelFriendRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMDelFriendRsp* other);

  // implements Message ----------------------------------------------

  IMDelFriendRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMDelFriendRsp& from);
  void MergeFrom(const IMDelFriendRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 friend_id = 2;
  inline bool has_friend_id() const;
  inline void clear_friend_id();
  static const int kFriendIdFieldNumber = 2;
  inline ::google::protobuf::uint32 friend_id() const;
  inline void set_friend_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 3;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 3;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional bytes addition_msg = 4;
  inline bool has_addition_msg() const;
  inline void clear_addition_msg();
  static const int kAdditionMsgFieldNumber = 4;
  inline const ::std::string& addition_msg() const;
  inline void set_addition_msg(const ::std::string& value);
  inline void set_addition_msg(const char* value);
  inline void set_addition_msg(const void* value, size_t size);
  inline ::std::string* mutable_addition_msg();
  inline ::std::string* release_addition_msg();
  inline void set_allocated_addition_msg(::std::string* addition_msg);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMDelFriendRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_friend_id();
  inline void clear_has_friend_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_addition_msg();
  inline void clear_has_addition_msg();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 friend_id_;
  ::std::string* addition_msg_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 result_code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMDelFriendRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMDelFollowUserReq : public ::google::protobuf::MessageLite {
 public:
  IMDelFollowUserReq();
  virtual ~IMDelFollowUserReq();

  IMDelFollowUserReq(const IMDelFollowUserReq& from);

  inline IMDelFollowUserReq& operator=(const IMDelFollowUserReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMDelFollowUserReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMDelFollowUserReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMDelFollowUserReq* other);

  // implements Message ----------------------------------------------

  IMDelFollowUserReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMDelFollowUserReq& from);
  void MergeFrom(const IMDelFollowUserReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 friend_id = 2;
  inline bool has_friend_id() const;
  inline void clear_friend_id();
  static const int kFriendIdFieldNumber = 2;
  inline ::google::protobuf::uint32 friend_id() const;
  inline void set_friend_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMDelFollowUserReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_friend_id();
  inline void clear_has_friend_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 friend_id_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMDelFollowUserReq* default_instance_;
};
// -------------------------------------------------------------------

class IMDelFollowUserRsp : public ::google::protobuf::MessageLite {
 public:
  IMDelFollowUserRsp();
  virtual ~IMDelFollowUserRsp();

  IMDelFollowUserRsp(const IMDelFollowUserRsp& from);

  inline IMDelFollowUserRsp& operator=(const IMDelFollowUserRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMDelFollowUserRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMDelFollowUserRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMDelFollowUserRsp* other);

  // implements Message ----------------------------------------------

  IMDelFollowUserRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMDelFollowUserRsp& from);
  void MergeFrom(const IMDelFollowUserRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 friend_id = 2;
  inline bool has_friend_id() const;
  inline void clear_friend_id();
  static const int kFriendIdFieldNumber = 2;
  inline ::google::protobuf::uint32 friend_id() const;
  inline void set_friend_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 3;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 3;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMDelFollowUserRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_friend_id();
  inline void clear_has_friend_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 friend_id_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 result_code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMDelFollowUserRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMALLOnlineUserCntReq : public ::google::protobuf::MessageLite {
 public:
  IMALLOnlineUserCntReq();
  virtual ~IMALLOnlineUserCntReq();

  IMALLOnlineUserCntReq(const IMALLOnlineUserCntReq& from);

  inline IMALLOnlineUserCntReq& operator=(const IMALLOnlineUserCntReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMALLOnlineUserCntReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMALLOnlineUserCntReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMALLOnlineUserCntReq* other);

  // implements Message ----------------------------------------------

  IMALLOnlineUserCntReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMALLOnlineUserCntReq& from);
  void MergeFrom(const IMALLOnlineUserCntReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMALLOnlineUserCntReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMALLOnlineUserCntReq* default_instance_;
};
// -------------------------------------------------------------------

class IMALLOnlineUserCntRsp : public ::google::protobuf::MessageLite {
 public:
  IMALLOnlineUserCntRsp();
  virtual ~IMALLOnlineUserCntRsp();

  IMALLOnlineUserCntRsp(const IMALLOnlineUserCntRsp& from);

  inline IMALLOnlineUserCntRsp& operator=(const IMALLOnlineUserCntRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMALLOnlineUserCntRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMALLOnlineUserCntRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMALLOnlineUserCntRsp* other);

  // implements Message ----------------------------------------------

  IMALLOnlineUserCntRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMALLOnlineUserCntRsp& from);
  void MergeFrom(const IMALLOnlineUserCntRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 online_user_cnt = 2;
  inline bool has_online_user_cnt() const;
  inline void clear_online_user_cnt();
  static const int kOnlineUserCntFieldNumber = 2;
  inline ::google::protobuf::uint32 online_user_cnt() const;
  inline void set_online_user_cnt(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMALLOnlineUserCntRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_online_user_cnt();
  inline void clear_has_online_user_cnt();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 online_user_cnt_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMALLOnlineUserCntRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMUpdateUsersInfoReq : public ::google::protobuf::MessageLite {
 public:
  IMUpdateUsersInfoReq();
  virtual ~IMUpdateUsersInfoReq();

  IMUpdateUsersInfoReq(const IMUpdateUsersInfoReq& from);

  inline IMUpdateUsersInfoReq& operator=(const IMUpdateUsersInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUpdateUsersInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUpdateUsersInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUpdateUsersInfoReq* other);

  // implements Message ----------------------------------------------

  IMUpdateUsersInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUpdateUsersInfoReq& from);
  void MergeFrom(const IMUpdateUsersInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.UserInfo user_info = 2;
  inline bool has_user_info() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 2;
  inline const ::IM::BaseDefine::UserInfo& user_info() const;
  inline ::IM::BaseDefine::UserInfo* mutable_user_info();
  inline ::IM::BaseDefine::UserInfo* release_user_info();
  inline void set_allocated_user_info(::IM::BaseDefine::UserInfo* user_info);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUpdateUsersInfoReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_info();
  inline void clear_has_user_info();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::IM::BaseDefine::UserInfo* user_info_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUpdateUsersInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class IMUpdateUsersInfoRsp : public ::google::protobuf::MessageLite {
 public:
  IMUpdateUsersInfoRsp();
  virtual ~IMUpdateUsersInfoRsp();

  IMUpdateUsersInfoRsp(const IMUpdateUsersInfoRsp& from);

  inline IMUpdateUsersInfoRsp& operator=(const IMUpdateUsersInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUpdateUsersInfoRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUpdateUsersInfoRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUpdateUsersInfoRsp* other);

  // implements Message ----------------------------------------------

  IMUpdateUsersInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUpdateUsersInfoRsp& from);
  void MergeFrom(const IMUpdateUsersInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUpdateUsersInfoRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUpdateUsersInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMRecommendListReq : public ::google::protobuf::MessageLite {
 public:
  IMRecommendListReq();
  virtual ~IMRecommendListReq();

  IMRecommendListReq(const IMRecommendListReq& from);

  inline IMRecommendListReq& operator=(const IMRecommendListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRecommendListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRecommendListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRecommendListReq* other);

  // implements Message ----------------------------------------------

  IMRecommendListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRecommendListReq& from);
  void MergeFrom(const IMRecommendListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 page = 2;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 2;
  inline ::google::protobuf::uint32 page() const;
  inline void set_page(::google::protobuf::uint32 value);

  // required uint32 page_size = 3;
  inline bool has_page_size() const;
  inline void clear_page_size();
  static const int kPageSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 page_size() const;
  inline void set_page_size(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRecommendListReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_page_size();
  inline void clear_has_page_size();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 page_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 page_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRecommendListReq* default_instance_;
};
// -------------------------------------------------------------------

class IMRecommendListRsp : public ::google::protobuf::MessageLite {
 public:
  IMRecommendListRsp();
  virtual ~IMRecommendListRsp();

  IMRecommendListRsp(const IMRecommendListRsp& from);

  inline IMRecommendListRsp& operator=(const IMRecommendListRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRecommendListRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRecommendListRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRecommendListRsp* other);

  // implements Message ----------------------------------------------

  IMRecommendListRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRecommendListRsp& from);
  void MergeFrom(const IMRecommendListRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 recommend_list = 1;
  inline int recommend_list_size() const;
  inline void clear_recommend_list();
  static const int kRecommendListFieldNumber = 1;
  inline ::google::protobuf::uint32 recommend_list(int index) const;
  inline void set_recommend_list(int index, ::google::protobuf::uint32 value);
  inline void add_recommend_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      recommend_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_recommend_list();

  // repeated string recommend_nick_list = 2;
  inline int recommend_nick_list_size() const;
  inline void clear_recommend_nick_list();
  static const int kRecommendNickListFieldNumber = 2;
  inline const ::std::string& recommend_nick_list(int index) const;
  inline ::std::string* mutable_recommend_nick_list(int index);
  inline void set_recommend_nick_list(int index, const ::std::string& value);
  inline void set_recommend_nick_list(int index, const char* value);
  inline void set_recommend_nick_list(int index, const char* value, size_t size);
  inline ::std::string* add_recommend_nick_list();
  inline void add_recommend_nick_list(const ::std::string& value);
  inline void add_recommend_nick_list(const char* value);
  inline void add_recommend_nick_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& recommend_nick_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_recommend_nick_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRecommendListRsp)
 private:
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > recommend_list_;
  ::google::protobuf::RepeatedPtrField< ::std::string> recommend_nick_list_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRecommendListRsp* default_instance_;
};
// ===================================================================


// ===================================================================

// IMRecentContactSessionReq

// required uint32 user_id = 1;
inline bool IMRecentContactSessionReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRecentContactSessionReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRecentContactSessionReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRecentContactSessionReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRecentContactSessionReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionReq.user_id)
  return user_id_;
}
inline void IMRecentContactSessionReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecentContactSessionReq.user_id)
}

// required uint32 latest_update_time = 2;
inline bool IMRecentContactSessionReq::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRecentContactSessionReq::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRecentContactSessionReq::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRecentContactSessionReq::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMRecentContactSessionReq::latest_update_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionReq.latest_update_time)
  return latest_update_time_;
}
inline void IMRecentContactSessionReq::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecentContactSessionReq.latest_update_time)
}

// optional bytes attach_data = 20;
inline bool IMRecentContactSessionReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRecentContactSessionReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRecentContactSessionReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRecentContactSessionReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRecentContactSessionReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionReq.attach_data)
  return *attach_data_;
}
inline void IMRecentContactSessionReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecentContactSessionReq.attach_data)
}
inline void IMRecentContactSessionReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMRecentContactSessionReq.attach_data)
}
inline void IMRecentContactSessionReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMRecentContactSessionReq.attach_data)
}
inline ::std::string* IMRecentContactSessionReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRecentContactSessionReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMRecentContactSessionReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRecentContactSessionReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMRecentContactSessionReq.attach_data)
}

// -------------------------------------------------------------------

// IMRecentContactSessionRsp

// required uint32 user_id = 1;
inline bool IMRecentContactSessionRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRecentContactSessionRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRecentContactSessionRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRecentContactSessionRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRecentContactSessionRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionRsp.user_id)
  return user_id_;
}
inline void IMRecentContactSessionRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecentContactSessionRsp.user_id)
}

// repeated .IM.BaseDefine.ContactSessionInfo contact_session_list = 2;
inline int IMRecentContactSessionRsp::contact_session_list_size() const {
  return contact_session_list_.size();
}
inline void IMRecentContactSessionRsp::clear_contact_session_list() {
  contact_session_list_.Clear();
}
inline const ::IM::BaseDefine::ContactSessionInfo& IMRecentContactSessionRsp::contact_session_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionRsp.contact_session_list)
  return contact_session_list_.Get(index);
}
inline ::IM::BaseDefine::ContactSessionInfo* IMRecentContactSessionRsp::mutable_contact_session_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRecentContactSessionRsp.contact_session_list)
  return contact_session_list_.Mutable(index);
}
inline ::IM::BaseDefine::ContactSessionInfo* IMRecentContactSessionRsp::add_contact_session_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMRecentContactSessionRsp.contact_session_list)
  return contact_session_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo >&
IMRecentContactSessionRsp::contact_session_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMRecentContactSessionRsp.contact_session_list)
  return contact_session_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo >*
IMRecentContactSessionRsp::mutable_contact_session_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMRecentContactSessionRsp.contact_session_list)
  return &contact_session_list_;
}

// optional bytes attach_data = 20;
inline bool IMRecentContactSessionRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRecentContactSessionRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRecentContactSessionRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRecentContactSessionRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRecentContactSessionRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionRsp.attach_data)
  return *attach_data_;
}
inline void IMRecentContactSessionRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecentContactSessionRsp.attach_data)
}
inline void IMRecentContactSessionRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMRecentContactSessionRsp.attach_data)
}
inline void IMRecentContactSessionRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMRecentContactSessionRsp.attach_data)
}
inline ::std::string* IMRecentContactSessionRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRecentContactSessionRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMRecentContactSessionRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRecentContactSessionRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMRecentContactSessionRsp.attach_data)
}

// -------------------------------------------------------------------

// IMUserStatNotify

// required .IM.BaseDefine.UserStat user_stat = 1;
inline bool IMUserStatNotify::has_user_stat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUserStatNotify::set_has_user_stat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUserStatNotify::clear_has_user_stat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUserStatNotify::clear_user_stat() {
  if (user_stat_ != NULL) user_stat_->::IM::BaseDefine::UserStat::Clear();
  clear_has_user_stat();
}
inline const ::IM::BaseDefine::UserStat& IMUserStatNotify::user_stat() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserStatNotify.user_stat)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_stat_ != NULL ? *user_stat_ : *default_instance().user_stat_;
#else
  return user_stat_ != NULL ? *user_stat_ : *default_instance_->user_stat_;
#endif
}
inline ::IM::BaseDefine::UserStat* IMUserStatNotify::mutable_user_stat() {
  set_has_user_stat();
  if (user_stat_ == NULL) user_stat_ = new ::IM::BaseDefine::UserStat;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserStatNotify.user_stat)
  return user_stat_;
}
inline ::IM::BaseDefine::UserStat* IMUserStatNotify::release_user_stat() {
  clear_has_user_stat();
  ::IM::BaseDefine::UserStat* temp = user_stat_;
  user_stat_ = NULL;
  return temp;
}
inline void IMUserStatNotify::set_allocated_user_stat(::IM::BaseDefine::UserStat* user_stat) {
  delete user_stat_;
  user_stat_ = user_stat;
  if (user_stat) {
    set_has_user_stat();
  } else {
    clear_has_user_stat();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserStatNotify.user_stat)
}

// -------------------------------------------------------------------

// IMUsersInfoReq

// required uint32 user_id = 1;
inline bool IMUsersInfoReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUsersInfoReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUsersInfoReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUsersInfoReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUsersInfoReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoReq.user_id)
  return user_id_;
}
inline void IMUsersInfoReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersInfoReq.user_id)
}

// repeated uint32 user_id_list = 2;
inline int IMUsersInfoReq::user_id_list_size() const {
  return user_id_list_.size();
}
inline void IMUsersInfoReq::clear_user_id_list() {
  user_id_list_.Clear();
}
inline ::google::protobuf::uint32 IMUsersInfoReq::user_id_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoReq.user_id_list)
  return user_id_list_.Get(index);
}
inline void IMUsersInfoReq::set_user_id_list(int index, ::google::protobuf::uint32 value) {
  user_id_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersInfoReq.user_id_list)
}
inline void IMUsersInfoReq::add_user_id_list(::google::protobuf::uint32 value) {
  user_id_list_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Buddy.IMUsersInfoReq.user_id_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMUsersInfoReq::user_id_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMUsersInfoReq.user_id_list)
  return user_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMUsersInfoReq::mutable_user_id_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMUsersInfoReq.user_id_list)
  return &user_id_list_;
}

// optional bytes attach_data = 20;
inline bool IMUsersInfoReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUsersInfoReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUsersInfoReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUsersInfoReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUsersInfoReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoReq.attach_data)
  return *attach_data_;
}
inline void IMUsersInfoReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersInfoReq.attach_data)
}
inline void IMUsersInfoReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUsersInfoReq.attach_data)
}
inline void IMUsersInfoReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUsersInfoReq.attach_data)
}
inline ::std::string* IMUsersInfoReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersInfoReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMUsersInfoReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUsersInfoReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUsersInfoReq.attach_data)
}

// -------------------------------------------------------------------

// IMUsersInfoRsp

// required uint32 user_id = 1;
inline bool IMUsersInfoRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUsersInfoRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUsersInfoRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUsersInfoRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUsersInfoRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoRsp.user_id)
  return user_id_;
}
inline void IMUsersInfoRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersInfoRsp.user_id)
}

// repeated .IM.BaseDefine.UserInfo user_info_list = 2;
inline int IMUsersInfoRsp::user_info_list_size() const {
  return user_info_list_.size();
}
inline void IMUsersInfoRsp::clear_user_info_list() {
  user_info_list_.Clear();
}
inline const ::IM::BaseDefine::UserInfo& IMUsersInfoRsp::user_info_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoRsp.user_info_list)
  return user_info_list_.Get(index);
}
inline ::IM::BaseDefine::UserInfo* IMUsersInfoRsp::mutable_user_info_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersInfoRsp.user_info_list)
  return user_info_list_.Mutable(index);
}
inline ::IM::BaseDefine::UserInfo* IMUsersInfoRsp::add_user_info_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMUsersInfoRsp.user_info_list)
  return user_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
IMUsersInfoRsp::user_info_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMUsersInfoRsp.user_info_list)
  return user_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
IMUsersInfoRsp::mutable_user_info_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMUsersInfoRsp.user_info_list)
  return &user_info_list_;
}

// optional bytes attach_data = 20;
inline bool IMUsersInfoRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUsersInfoRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUsersInfoRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUsersInfoRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUsersInfoRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoRsp.attach_data)
  return *attach_data_;
}
inline void IMUsersInfoRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersInfoRsp.attach_data)
}
inline void IMUsersInfoRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUsersInfoRsp.attach_data)
}
inline void IMUsersInfoRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUsersInfoRsp.attach_data)
}
inline ::std::string* IMUsersInfoRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersInfoRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMUsersInfoRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUsersInfoRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUsersInfoRsp.attach_data)
}

// -------------------------------------------------------------------

// IMRemoveSessionReq

// required uint32 user_id = 1;
inline bool IMRemoveSessionReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRemoveSessionReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRemoveSessionReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRemoveSessionReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionReq.user_id)
  return user_id_;
}
inline void IMRemoveSessionReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionReq.user_id)
}

// required .IM.BaseDefine.SessionType session_type = 2;
inline bool IMRemoveSessionReq::has_session_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRemoveSessionReq::set_has_session_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRemoveSessionReq::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRemoveSessionReq::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline ::IM::BaseDefine::SessionType IMRemoveSessionReq::session_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionReq.session_type)
  return static_cast< ::IM::BaseDefine::SessionType >(session_type_);
}
inline void IMRemoveSessionReq::set_session_type(::IM::BaseDefine::SessionType value) {
  assert(::IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionReq.session_type)
}

// required uint32 session_id = 3;
inline bool IMRemoveSessionReq::has_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRemoveSessionReq::set_has_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRemoveSessionReq::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRemoveSessionReq::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionReq::session_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionReq.session_id)
  return session_id_;
}
inline void IMRemoveSessionReq::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionReq.session_id)
}

// optional bytes attach_data = 20;
inline bool IMRemoveSessionReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMRemoveSessionReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMRemoveSessionReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMRemoveSessionReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRemoveSessionReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionReq.attach_data)
  return *attach_data_;
}
inline void IMRemoveSessionReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionReq.attach_data)
}
inline void IMRemoveSessionReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMRemoveSessionReq.attach_data)
}
inline void IMRemoveSessionReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMRemoveSessionReq.attach_data)
}
inline ::std::string* IMRemoveSessionReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRemoveSessionReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMRemoveSessionReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRemoveSessionReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMRemoveSessionReq.attach_data)
}

// -------------------------------------------------------------------

// IMRemoveSessionRsp

// required uint32 user_id = 1;
inline bool IMRemoveSessionRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRemoveSessionRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRemoveSessionRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRemoveSessionRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionRsp.user_id)
  return user_id_;
}
inline void IMRemoveSessionRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionRsp.user_id)
}

// required uint32 result_code = 2;
inline bool IMRemoveSessionRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRemoveSessionRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRemoveSessionRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRemoveSessionRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMRemoveSessionRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionRsp.result_code)
  return result_code_;
}
inline void IMRemoveSessionRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionRsp.result_code)
}

// required .IM.BaseDefine.SessionType session_type = 3;
inline bool IMRemoveSessionRsp::has_session_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRemoveSessionRsp::set_has_session_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRemoveSessionRsp::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRemoveSessionRsp::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline ::IM::BaseDefine::SessionType IMRemoveSessionRsp::session_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionRsp.session_type)
  return static_cast< ::IM::BaseDefine::SessionType >(session_type_);
}
inline void IMRemoveSessionRsp::set_session_type(::IM::BaseDefine::SessionType value) {
  assert(::IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionRsp.session_type)
}

// required uint32 session_id = 4;
inline bool IMRemoveSessionRsp::has_session_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMRemoveSessionRsp::set_has_session_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMRemoveSessionRsp::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMRemoveSessionRsp::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionRsp::session_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionRsp.session_id)
  return session_id_;
}
inline void IMRemoveSessionRsp::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionRsp.session_id)
}

// optional bytes attach_data = 20;
inline bool IMRemoveSessionRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMRemoveSessionRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMRemoveSessionRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMRemoveSessionRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRemoveSessionRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionRsp.attach_data)
  return *attach_data_;
}
inline void IMRemoveSessionRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionRsp.attach_data)
}
inline void IMRemoveSessionRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMRemoveSessionRsp.attach_data)
}
inline void IMRemoveSessionRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMRemoveSessionRsp.attach_data)
}
inline ::std::string* IMRemoveSessionRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRemoveSessionRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMRemoveSessionRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRemoveSessionRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMRemoveSessionRsp.attach_data)
}

// -------------------------------------------------------------------

// IMAllUserReq

// required uint32 user_id = 1;
inline bool IMAllUserReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAllUserReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAllUserReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAllUserReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMAllUserReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserReq.user_id)
  return user_id_;
}
inline void IMAllUserReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserReq.user_id)
}

// required uint32 latest_update_time = 2;
inline bool IMAllUserReq::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAllUserReq::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAllUserReq::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAllUserReq::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMAllUserReq::latest_update_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserReq.latest_update_time)
  return latest_update_time_;
}
inline void IMAllUserReq::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserReq.latest_update_time)
}

// optional bytes attach_data = 20;
inline bool IMAllUserReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMAllUserReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMAllUserReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMAllUserReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMAllUserReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserReq.attach_data)
  return *attach_data_;
}
inline void IMAllUserReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserReq.attach_data)
}
inline void IMAllUserReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAllUserReq.attach_data)
}
inline void IMAllUserReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAllUserReq.attach_data)
}
inline ::std::string* IMAllUserReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAllUserReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMAllUserReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAllUserReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAllUserReq.attach_data)
}

// -------------------------------------------------------------------

// IMAllUserRsp

// required uint32 user_id = 1;
inline bool IMAllUserRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAllUserRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAllUserRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAllUserRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMAllUserRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserRsp.user_id)
  return user_id_;
}
inline void IMAllUserRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserRsp.user_id)
}

// required uint32 latest_update_time = 2;
inline bool IMAllUserRsp::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAllUserRsp::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAllUserRsp::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAllUserRsp::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMAllUserRsp::latest_update_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserRsp.latest_update_time)
  return latest_update_time_;
}
inline void IMAllUserRsp::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserRsp.latest_update_time)
}

// repeated .IM.BaseDefine.UserInfo user_list = 3;
inline int IMAllUserRsp::user_list_size() const {
  return user_list_.size();
}
inline void IMAllUserRsp::clear_user_list() {
  user_list_.Clear();
}
inline const ::IM::BaseDefine::UserInfo& IMAllUserRsp::user_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserRsp.user_list)
  return user_list_.Get(index);
}
inline ::IM::BaseDefine::UserInfo* IMAllUserRsp::mutable_user_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAllUserRsp.user_list)
  return user_list_.Mutable(index);
}
inline ::IM::BaseDefine::UserInfo* IMAllUserRsp::add_user_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMAllUserRsp.user_list)
  return user_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
IMAllUserRsp::user_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMAllUserRsp.user_list)
  return user_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
IMAllUserRsp::mutable_user_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMAllUserRsp.user_list)
  return &user_list_;
}

// optional bytes attach_data = 20;
inline bool IMAllUserRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMAllUserRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMAllUserRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMAllUserRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMAllUserRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserRsp.attach_data)
  return *attach_data_;
}
inline void IMAllUserRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserRsp.attach_data)
}
inline void IMAllUserRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAllUserRsp.attach_data)
}
inline void IMAllUserRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAllUserRsp.attach_data)
}
inline ::std::string* IMAllUserRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAllUserRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMAllUserRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAllUserRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAllUserRsp.attach_data)
}

// -------------------------------------------------------------------

// IMUsersStatReq

// required uint32 user_id = 1;
inline bool IMUsersStatReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUsersStatReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUsersStatReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUsersStatReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUsersStatReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatReq.user_id)
  return user_id_;
}
inline void IMUsersStatReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersStatReq.user_id)
}

// repeated uint32 user_id_list = 2;
inline int IMUsersStatReq::user_id_list_size() const {
  return user_id_list_.size();
}
inline void IMUsersStatReq::clear_user_id_list() {
  user_id_list_.Clear();
}
inline ::google::protobuf::uint32 IMUsersStatReq::user_id_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatReq.user_id_list)
  return user_id_list_.Get(index);
}
inline void IMUsersStatReq::set_user_id_list(int index, ::google::protobuf::uint32 value) {
  user_id_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersStatReq.user_id_list)
}
inline void IMUsersStatReq::add_user_id_list(::google::protobuf::uint32 value) {
  user_id_list_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Buddy.IMUsersStatReq.user_id_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMUsersStatReq::user_id_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMUsersStatReq.user_id_list)
  return user_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMUsersStatReq::mutable_user_id_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMUsersStatReq.user_id_list)
  return &user_id_list_;
}

// optional bytes attach_data = 20;
inline bool IMUsersStatReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUsersStatReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUsersStatReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUsersStatReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUsersStatReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatReq.attach_data)
  return *attach_data_;
}
inline void IMUsersStatReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersStatReq.attach_data)
}
inline void IMUsersStatReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUsersStatReq.attach_data)
}
inline void IMUsersStatReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUsersStatReq.attach_data)
}
inline ::std::string* IMUsersStatReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersStatReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMUsersStatReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUsersStatReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUsersStatReq.attach_data)
}

// -------------------------------------------------------------------

// IMUsersStatRsp

// required uint32 user_id = 1;
inline bool IMUsersStatRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUsersStatRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUsersStatRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUsersStatRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUsersStatRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatRsp.user_id)
  return user_id_;
}
inline void IMUsersStatRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersStatRsp.user_id)
}

// repeated .IM.BaseDefine.UserStat user_stat_list = 2;
inline int IMUsersStatRsp::user_stat_list_size() const {
  return user_stat_list_.size();
}
inline void IMUsersStatRsp::clear_user_stat_list() {
  user_stat_list_.Clear();
}
inline const ::IM::BaseDefine::UserStat& IMUsersStatRsp::user_stat_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatRsp.user_stat_list)
  return user_stat_list_.Get(index);
}
inline ::IM::BaseDefine::UserStat* IMUsersStatRsp::mutable_user_stat_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersStatRsp.user_stat_list)
  return user_stat_list_.Mutable(index);
}
inline ::IM::BaseDefine::UserStat* IMUsersStatRsp::add_user_stat_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMUsersStatRsp.user_stat_list)
  return user_stat_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat >&
IMUsersStatRsp::user_stat_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMUsersStatRsp.user_stat_list)
  return user_stat_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat >*
IMUsersStatRsp::mutable_user_stat_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMUsersStatRsp.user_stat_list)
  return &user_stat_list_;
}

// optional bytes attach_data = 20;
inline bool IMUsersStatRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUsersStatRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUsersStatRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUsersStatRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUsersStatRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatRsp.attach_data)
  return *attach_data_;
}
inline void IMUsersStatRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersStatRsp.attach_data)
}
inline void IMUsersStatRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUsersStatRsp.attach_data)
}
inline void IMUsersStatRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUsersStatRsp.attach_data)
}
inline ::std::string* IMUsersStatRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersStatRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMUsersStatRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUsersStatRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUsersStatRsp.attach_data)
}

// -------------------------------------------------------------------

// IMChangeAvatarReq

// required uint32 user_id = 1;
inline bool IMChangeAvatarReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMChangeAvatarReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMChangeAvatarReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMChangeAvatarReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMChangeAvatarReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarReq.user_id)
  return user_id_;
}
inline void IMChangeAvatarReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarReq.user_id)
}

// required string avatar_url = 2;
inline bool IMChangeAvatarReq::has_avatar_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMChangeAvatarReq::set_has_avatar_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMChangeAvatarReq::clear_has_avatar_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMChangeAvatarReq::clear_avatar_url() {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_->clear();
  }
  clear_has_avatar_url();
}
inline const ::std::string& IMChangeAvatarReq::avatar_url() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarReq.avatar_url)
  return *avatar_url_;
}
inline void IMChangeAvatarReq::set_avatar_url(const ::std::string& value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarReq.avatar_url)
}
inline void IMChangeAvatarReq::set_avatar_url(const char* value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeAvatarReq.avatar_url)
}
inline void IMChangeAvatarReq::set_avatar_url(const char* value, size_t size) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeAvatarReq.avatar_url)
}
inline ::std::string* IMChangeAvatarReq::mutable_avatar_url() {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeAvatarReq.avatar_url)
  return avatar_url_;
}
inline ::std::string* IMChangeAvatarReq::release_avatar_url() {
  clear_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatar_url_;
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeAvatarReq::set_allocated_avatar_url(::std::string* avatar_url) {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_url_;
  }
  if (avatar_url) {
    set_has_avatar_url();
    avatar_url_ = avatar_url;
  } else {
    clear_has_avatar_url();
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeAvatarReq.avatar_url)
}

// optional bytes attach_data = 20;
inline bool IMChangeAvatarReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMChangeAvatarReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMChangeAvatarReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMChangeAvatarReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMChangeAvatarReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarReq.attach_data)
  return *attach_data_;
}
inline void IMChangeAvatarReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarReq.attach_data)
}
inline void IMChangeAvatarReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeAvatarReq.attach_data)
}
inline void IMChangeAvatarReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeAvatarReq.attach_data)
}
inline ::std::string* IMChangeAvatarReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeAvatarReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMChangeAvatarReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeAvatarReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeAvatarReq.attach_data)
}

// -------------------------------------------------------------------

// IMChangeAvatarRsp

// required uint32 user_id = 1;
inline bool IMChangeAvatarRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMChangeAvatarRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMChangeAvatarRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMChangeAvatarRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMChangeAvatarRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarRsp.user_id)
  return user_id_;
}
inline void IMChangeAvatarRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarRsp.user_id)
}

// required uint32 result_code = 2;
inline bool IMChangeAvatarRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMChangeAvatarRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMChangeAvatarRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMChangeAvatarRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMChangeAvatarRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarRsp.result_code)
  return result_code_;
}
inline void IMChangeAvatarRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarRsp.result_code)
}

// optional bytes attach_data = 20;
inline bool IMChangeAvatarRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMChangeAvatarRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMChangeAvatarRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMChangeAvatarRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMChangeAvatarRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarRsp.attach_data)
  return *attach_data_;
}
inline void IMChangeAvatarRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarRsp.attach_data)
}
inline void IMChangeAvatarRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeAvatarRsp.attach_data)
}
inline void IMChangeAvatarRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeAvatarRsp.attach_data)
}
inline ::std::string* IMChangeAvatarRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeAvatarRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMChangeAvatarRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeAvatarRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeAvatarRsp.attach_data)
}

// -------------------------------------------------------------------

// IMPCLoginStatusNotify

// required uint32 user_id = 1;
inline bool IMPCLoginStatusNotify::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMPCLoginStatusNotify::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMPCLoginStatusNotify::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMPCLoginStatusNotify::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMPCLoginStatusNotify::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMPCLoginStatusNotify.user_id)
  return user_id_;
}
inline void IMPCLoginStatusNotify::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMPCLoginStatusNotify.user_id)
}

// required .IM.BaseDefine.UserStatType login_stat = 2;
inline bool IMPCLoginStatusNotify::has_login_stat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMPCLoginStatusNotify::set_has_login_stat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMPCLoginStatusNotify::clear_has_login_stat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMPCLoginStatusNotify::clear_login_stat() {
  login_stat_ = 1;
  clear_has_login_stat();
}
inline ::IM::BaseDefine::UserStatType IMPCLoginStatusNotify::login_stat() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMPCLoginStatusNotify.login_stat)
  return static_cast< ::IM::BaseDefine::UserStatType >(login_stat_);
}
inline void IMPCLoginStatusNotify::set_login_stat(::IM::BaseDefine::UserStatType value) {
  assert(::IM::BaseDefine::UserStatType_IsValid(value));
  set_has_login_stat();
  login_stat_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMPCLoginStatusNotify.login_stat)
}

// -------------------------------------------------------------------

// IMRemoveSessionNotify

// required uint32 user_id = 1;
inline bool IMRemoveSessionNotify::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRemoveSessionNotify::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRemoveSessionNotify::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRemoveSessionNotify::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionNotify::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionNotify.user_id)
  return user_id_;
}
inline void IMRemoveSessionNotify::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionNotify.user_id)
}

// required .IM.BaseDefine.SessionType session_type = 2;
inline bool IMRemoveSessionNotify::has_session_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRemoveSessionNotify::set_has_session_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRemoveSessionNotify::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRemoveSessionNotify::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline ::IM::BaseDefine::SessionType IMRemoveSessionNotify::session_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionNotify.session_type)
  return static_cast< ::IM::BaseDefine::SessionType >(session_type_);
}
inline void IMRemoveSessionNotify::set_session_type(::IM::BaseDefine::SessionType value) {
  assert(::IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionNotify.session_type)
}

// required uint32 session_id = 3;
inline bool IMRemoveSessionNotify::has_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRemoveSessionNotify::set_has_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRemoveSessionNotify::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRemoveSessionNotify::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionNotify::session_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionNotify.session_id)
  return session_id_;
}
inline void IMRemoveSessionNotify::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionNotify.session_id)
}

// -------------------------------------------------------------------

// IMDepartmentReq

// required uint32 user_id = 1;
inline bool IMDepartmentReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMDepartmentReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMDepartmentReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMDepartmentReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMDepartmentReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentReq.user_id)
  return user_id_;
}
inline void IMDepartmentReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentReq.user_id)
}

// required uint32 latest_update_time = 2;
inline bool IMDepartmentReq::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMDepartmentReq::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMDepartmentReq::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMDepartmentReq::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMDepartmentReq::latest_update_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentReq.latest_update_time)
  return latest_update_time_;
}
inline void IMDepartmentReq::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentReq.latest_update_time)
}

// optional bytes attach_data = 20;
inline bool IMDepartmentReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMDepartmentReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMDepartmentReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMDepartmentReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMDepartmentReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentReq.attach_data)
  return *attach_data_;
}
inline void IMDepartmentReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentReq.attach_data)
}
inline void IMDepartmentReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMDepartmentReq.attach_data)
}
inline void IMDepartmentReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMDepartmentReq.attach_data)
}
inline ::std::string* IMDepartmentReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMDepartmentReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMDepartmentReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMDepartmentReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMDepartmentReq.attach_data)
}

// -------------------------------------------------------------------

// IMDepartmentRsp

// required uint32 user_id = 1;
inline bool IMDepartmentRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMDepartmentRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMDepartmentRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMDepartmentRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMDepartmentRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentRsp.user_id)
  return user_id_;
}
inline void IMDepartmentRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentRsp.user_id)
}

// required uint32 latest_update_time = 2;
inline bool IMDepartmentRsp::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMDepartmentRsp::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMDepartmentRsp::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMDepartmentRsp::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMDepartmentRsp::latest_update_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentRsp.latest_update_time)
  return latest_update_time_;
}
inline void IMDepartmentRsp::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentRsp.latest_update_time)
}

// repeated .IM.BaseDefine.DepartInfo dept_list = 3;
inline int IMDepartmentRsp::dept_list_size() const {
  return dept_list_.size();
}
inline void IMDepartmentRsp::clear_dept_list() {
  dept_list_.Clear();
}
inline const ::IM::BaseDefine::DepartInfo& IMDepartmentRsp::dept_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentRsp.dept_list)
  return dept_list_.Get(index);
}
inline ::IM::BaseDefine::DepartInfo* IMDepartmentRsp::mutable_dept_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMDepartmentRsp.dept_list)
  return dept_list_.Mutable(index);
}
inline ::IM::BaseDefine::DepartInfo* IMDepartmentRsp::add_dept_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMDepartmentRsp.dept_list)
  return dept_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo >&
IMDepartmentRsp::dept_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMDepartmentRsp.dept_list)
  return dept_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo >*
IMDepartmentRsp::mutable_dept_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMDepartmentRsp.dept_list)
  return &dept_list_;
}

// optional bytes attach_data = 20;
inline bool IMDepartmentRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMDepartmentRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMDepartmentRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMDepartmentRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMDepartmentRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentRsp.attach_data)
  return *attach_data_;
}
inline void IMDepartmentRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentRsp.attach_data)
}
inline void IMDepartmentRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMDepartmentRsp.attach_data)
}
inline void IMDepartmentRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMDepartmentRsp.attach_data)
}
inline ::std::string* IMDepartmentRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMDepartmentRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMDepartmentRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMDepartmentRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMDepartmentRsp.attach_data)
}

// -------------------------------------------------------------------

// IMAvatarChangedNotify

// required uint32 changed_user_id = 1;
inline bool IMAvatarChangedNotify::has_changed_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAvatarChangedNotify::set_has_changed_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAvatarChangedNotify::clear_has_changed_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAvatarChangedNotify::clear_changed_user_id() {
  changed_user_id_ = 0u;
  clear_has_changed_user_id();
}
inline ::google::protobuf::uint32 IMAvatarChangedNotify::changed_user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAvatarChangedNotify.changed_user_id)
  return changed_user_id_;
}
inline void IMAvatarChangedNotify::set_changed_user_id(::google::protobuf::uint32 value) {
  set_has_changed_user_id();
  changed_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAvatarChangedNotify.changed_user_id)
}

// required string avatar_url = 2;
inline bool IMAvatarChangedNotify::has_avatar_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAvatarChangedNotify::set_has_avatar_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAvatarChangedNotify::clear_has_avatar_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAvatarChangedNotify::clear_avatar_url() {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_->clear();
  }
  clear_has_avatar_url();
}
inline const ::std::string& IMAvatarChangedNotify::avatar_url() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAvatarChangedNotify.avatar_url)
  return *avatar_url_;
}
inline void IMAvatarChangedNotify::set_avatar_url(const ::std::string& value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAvatarChangedNotify.avatar_url)
}
inline void IMAvatarChangedNotify::set_avatar_url(const char* value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAvatarChangedNotify.avatar_url)
}
inline void IMAvatarChangedNotify::set_avatar_url(const char* value, size_t size) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAvatarChangedNotify.avatar_url)
}
inline ::std::string* IMAvatarChangedNotify::mutable_avatar_url() {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAvatarChangedNotify.avatar_url)
  return avatar_url_;
}
inline ::std::string* IMAvatarChangedNotify::release_avatar_url() {
  clear_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatar_url_;
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAvatarChangedNotify::set_allocated_avatar_url(::std::string* avatar_url) {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_url_;
  }
  if (avatar_url) {
    set_has_avatar_url();
    avatar_url_ = avatar_url;
  } else {
    clear_has_avatar_url();
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAvatarChangedNotify.avatar_url)
}

// -------------------------------------------------------------------

// IMChangeSignInfoReq

// required uint32 user_id = 1;
inline bool IMChangeSignInfoReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMChangeSignInfoReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMChangeSignInfoReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMChangeSignInfoReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMChangeSignInfoReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoReq.user_id)
  return user_id_;
}
inline void IMChangeSignInfoReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoReq.user_id)
}

// required string sign_info = 2;
inline bool IMChangeSignInfoReq::has_sign_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMChangeSignInfoReq::set_has_sign_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMChangeSignInfoReq::clear_has_sign_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMChangeSignInfoReq::clear_sign_info() {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_->clear();
  }
  clear_has_sign_info();
}
inline const ::std::string& IMChangeSignInfoReq::sign_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoReq.sign_info)
  return *sign_info_;
}
inline void IMChangeSignInfoReq::set_sign_info(const ::std::string& value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoReq.sign_info)
}
inline void IMChangeSignInfoReq::set_sign_info(const char* value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeSignInfoReq.sign_info)
}
inline void IMChangeSignInfoReq::set_sign_info(const char* value, size_t size) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeSignInfoReq.sign_info)
}
inline ::std::string* IMChangeSignInfoReq::mutable_sign_info() {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeSignInfoReq.sign_info)
  return sign_info_;
}
inline ::std::string* IMChangeSignInfoReq::release_sign_info() {
  clear_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sign_info_;
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeSignInfoReq::set_allocated_sign_info(::std::string* sign_info) {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_info_;
  }
  if (sign_info) {
    set_has_sign_info();
    sign_info_ = sign_info;
  } else {
    clear_has_sign_info();
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeSignInfoReq.sign_info)
}

// optional bytes attach_data = 20;
inline bool IMChangeSignInfoReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMChangeSignInfoReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMChangeSignInfoReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMChangeSignInfoReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMChangeSignInfoReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoReq.attach_data)
  return *attach_data_;
}
inline void IMChangeSignInfoReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoReq.attach_data)
}
inline void IMChangeSignInfoReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeSignInfoReq.attach_data)
}
inline void IMChangeSignInfoReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeSignInfoReq.attach_data)
}
inline ::std::string* IMChangeSignInfoReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeSignInfoReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMChangeSignInfoReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeSignInfoReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeSignInfoReq.attach_data)
}

// -------------------------------------------------------------------

// IMChangeSignInfoRsp

// required uint32 user_id = 1;
inline bool IMChangeSignInfoRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMChangeSignInfoRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMChangeSignInfoRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMChangeSignInfoRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMChangeSignInfoRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoRsp.user_id)
  return user_id_;
}
inline void IMChangeSignInfoRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoRsp.user_id)
}

// required uint32 result_code = 2;
inline bool IMChangeSignInfoRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMChangeSignInfoRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMChangeSignInfoRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMChangeSignInfoRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMChangeSignInfoRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoRsp.result_code)
  return result_code_;
}
inline void IMChangeSignInfoRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoRsp.result_code)
}

// optional string sign_info = 3;
inline bool IMChangeSignInfoRsp::has_sign_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMChangeSignInfoRsp::set_has_sign_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMChangeSignInfoRsp::clear_has_sign_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMChangeSignInfoRsp::clear_sign_info() {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_->clear();
  }
  clear_has_sign_info();
}
inline const ::std::string& IMChangeSignInfoRsp::sign_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoRsp.sign_info)
  return *sign_info_;
}
inline void IMChangeSignInfoRsp::set_sign_info(const ::std::string& value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoRsp.sign_info)
}
inline void IMChangeSignInfoRsp::set_sign_info(const char* value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeSignInfoRsp.sign_info)
}
inline void IMChangeSignInfoRsp::set_sign_info(const char* value, size_t size) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeSignInfoRsp.sign_info)
}
inline ::std::string* IMChangeSignInfoRsp::mutable_sign_info() {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeSignInfoRsp.sign_info)
  return sign_info_;
}
inline ::std::string* IMChangeSignInfoRsp::release_sign_info() {
  clear_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sign_info_;
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeSignInfoRsp::set_allocated_sign_info(::std::string* sign_info) {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_info_;
  }
  if (sign_info) {
    set_has_sign_info();
    sign_info_ = sign_info;
  } else {
    clear_has_sign_info();
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeSignInfoRsp.sign_info)
}

// optional bytes attach_data = 20;
inline bool IMChangeSignInfoRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMChangeSignInfoRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMChangeSignInfoRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMChangeSignInfoRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMChangeSignInfoRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoRsp.attach_data)
  return *attach_data_;
}
inline void IMChangeSignInfoRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoRsp.attach_data)
}
inline void IMChangeSignInfoRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeSignInfoRsp.attach_data)
}
inline void IMChangeSignInfoRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeSignInfoRsp.attach_data)
}
inline ::std::string* IMChangeSignInfoRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeSignInfoRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMChangeSignInfoRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeSignInfoRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeSignInfoRsp.attach_data)
}

// -------------------------------------------------------------------

// IMSignInfoChangedNotify

// required uint32 changed_user_id = 1;
inline bool IMSignInfoChangedNotify::has_changed_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMSignInfoChangedNotify::set_has_changed_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMSignInfoChangedNotify::clear_has_changed_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMSignInfoChangedNotify::clear_changed_user_id() {
  changed_user_id_ = 0u;
  clear_has_changed_user_id();
}
inline ::google::protobuf::uint32 IMSignInfoChangedNotify::changed_user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMSignInfoChangedNotify.changed_user_id)
  return changed_user_id_;
}
inline void IMSignInfoChangedNotify::set_changed_user_id(::google::protobuf::uint32 value) {
  set_has_changed_user_id();
  changed_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMSignInfoChangedNotify.changed_user_id)
}

// required string sign_info = 2;
inline bool IMSignInfoChangedNotify::has_sign_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMSignInfoChangedNotify::set_has_sign_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMSignInfoChangedNotify::clear_has_sign_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMSignInfoChangedNotify::clear_sign_info() {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_->clear();
  }
  clear_has_sign_info();
}
inline const ::std::string& IMSignInfoChangedNotify::sign_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMSignInfoChangedNotify.sign_info)
  return *sign_info_;
}
inline void IMSignInfoChangedNotify::set_sign_info(const ::std::string& value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMSignInfoChangedNotify.sign_info)
}
inline void IMSignInfoChangedNotify::set_sign_info(const char* value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMSignInfoChangedNotify.sign_info)
}
inline void IMSignInfoChangedNotify::set_sign_info(const char* value, size_t size) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMSignInfoChangedNotify.sign_info)
}
inline ::std::string* IMSignInfoChangedNotify::mutable_sign_info() {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMSignInfoChangedNotify.sign_info)
  return sign_info_;
}
inline ::std::string* IMSignInfoChangedNotify::release_sign_info() {
  clear_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sign_info_;
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMSignInfoChangedNotify::set_allocated_sign_info(::std::string* sign_info) {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_info_;
  }
  if (sign_info) {
    set_has_sign_info();
    sign_info_ = sign_info;
  } else {
    clear_has_sign_info();
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMSignInfoChangedNotify.sign_info)
}

// -------------------------------------------------------------------

// IMSearchUserReq

// required uint32 user_id = 1;
inline bool IMSearchUserReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMSearchUserReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMSearchUserReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMSearchUserReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMSearchUserReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMSearchUserReq.user_id)
  return user_id_;
}
inline void IMSearchUserReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMSearchUserReq.user_id)
}

// required string search_user_name = 2;
inline bool IMSearchUserReq::has_search_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMSearchUserReq::set_has_search_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMSearchUserReq::clear_has_search_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMSearchUserReq::clear_search_user_name() {
  if (search_user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    search_user_name_->clear();
  }
  clear_has_search_user_name();
}
inline const ::std::string& IMSearchUserReq::search_user_name() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMSearchUserReq.search_user_name)
  return *search_user_name_;
}
inline void IMSearchUserReq::set_search_user_name(const ::std::string& value) {
  set_has_search_user_name();
  if (search_user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    search_user_name_ = new ::std::string;
  }
  search_user_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMSearchUserReq.search_user_name)
}
inline void IMSearchUserReq::set_search_user_name(const char* value) {
  set_has_search_user_name();
  if (search_user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    search_user_name_ = new ::std::string;
  }
  search_user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMSearchUserReq.search_user_name)
}
inline void IMSearchUserReq::set_search_user_name(const char* value, size_t size) {
  set_has_search_user_name();
  if (search_user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    search_user_name_ = new ::std::string;
  }
  search_user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMSearchUserReq.search_user_name)
}
inline ::std::string* IMSearchUserReq::mutable_search_user_name() {
  set_has_search_user_name();
  if (search_user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    search_user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMSearchUserReq.search_user_name)
  return search_user_name_;
}
inline ::std::string* IMSearchUserReq::release_search_user_name() {
  clear_has_search_user_name();
  if (search_user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = search_user_name_;
    search_user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMSearchUserReq::set_allocated_search_user_name(::std::string* search_user_name) {
  if (search_user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete search_user_name_;
  }
  if (search_user_name) {
    set_has_search_user_name();
    search_user_name_ = search_user_name;
  } else {
    clear_has_search_user_name();
    search_user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMSearchUserReq.search_user_name)
}

// optional bytes attach_data = 20;
inline bool IMSearchUserReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMSearchUserReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMSearchUserReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMSearchUserReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMSearchUserReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMSearchUserReq.attach_data)
  return *attach_data_;
}
inline void IMSearchUserReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMSearchUserReq.attach_data)
}
inline void IMSearchUserReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMSearchUserReq.attach_data)
}
inline void IMSearchUserReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMSearchUserReq.attach_data)
}
inline ::std::string* IMSearchUserReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMSearchUserReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMSearchUserReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMSearchUserReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMSearchUserReq.attach_data)
}

// -------------------------------------------------------------------

// IMSearchUserRsp

// required uint32 user_id = 1;
inline bool IMSearchUserRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMSearchUserRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMSearchUserRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMSearchUserRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMSearchUserRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMSearchUserRsp.user_id)
  return user_id_;
}
inline void IMSearchUserRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMSearchUserRsp.user_id)
}

// repeated .IM.BaseDefine.UserInfo search_user_list = 2;
inline int IMSearchUserRsp::search_user_list_size() const {
  return search_user_list_.size();
}
inline void IMSearchUserRsp::clear_search_user_list() {
  search_user_list_.Clear();
}
inline const ::IM::BaseDefine::UserInfo& IMSearchUserRsp::search_user_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMSearchUserRsp.search_user_list)
  return search_user_list_.Get(index);
}
inline ::IM::BaseDefine::UserInfo* IMSearchUserRsp::mutable_search_user_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMSearchUserRsp.search_user_list)
  return search_user_list_.Mutable(index);
}
inline ::IM::BaseDefine::UserInfo* IMSearchUserRsp::add_search_user_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMSearchUserRsp.search_user_list)
  return search_user_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
IMSearchUserRsp::search_user_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMSearchUserRsp.search_user_list)
  return search_user_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
IMSearchUserRsp::mutable_search_user_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMSearchUserRsp.search_user_list)
  return &search_user_list_;
}

// optional bytes attach_data = 20;
inline bool IMSearchUserRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMSearchUserRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMSearchUserRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMSearchUserRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMSearchUserRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMSearchUserRsp.attach_data)
  return *attach_data_;
}
inline void IMSearchUserRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMSearchUserRsp.attach_data)
}
inline void IMSearchUserRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMSearchUserRsp.attach_data)
}
inline void IMSearchUserRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMSearchUserRsp.attach_data)
}
inline ::std::string* IMSearchUserRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMSearchUserRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMSearchUserRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMSearchUserRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMSearchUserRsp.attach_data)
}

// -------------------------------------------------------------------

// IMAddFriendReq

// required uint32 user_id = 1;
inline bool IMAddFriendReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAddFriendReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAddFriendReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAddFriendReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMAddFriendReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendReq.user_id)
  return user_id_;
}
inline void IMAddFriendReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendReq.user_id)
}

// required uint32 friend_id = 2;
inline bool IMAddFriendReq::has_friend_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAddFriendReq::set_has_friend_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAddFriendReq::clear_has_friend_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAddFriendReq::clear_friend_id() {
  friend_id_ = 0u;
  clear_has_friend_id();
}
inline ::google::protobuf::uint32 IMAddFriendReq::friend_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendReq.friend_id)
  return friend_id_;
}
inline void IMAddFriendReq::set_friend_id(::google::protobuf::uint32 value) {
  set_has_friend_id();
  friend_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendReq.friend_id)
}

// optional bytes addition_msg = 3;
inline bool IMAddFriendReq::has_addition_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMAddFriendReq::set_has_addition_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMAddFriendReq::clear_has_addition_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMAddFriendReq::clear_addition_msg() {
  if (addition_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    addition_msg_->clear();
  }
  clear_has_addition_msg();
}
inline const ::std::string& IMAddFriendReq::addition_msg() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendReq.addition_msg)
  return *addition_msg_;
}
inline void IMAddFriendReq::set_addition_msg(const ::std::string& value) {
  set_has_addition_msg();
  if (addition_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    addition_msg_ = new ::std::string;
  }
  addition_msg_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendReq.addition_msg)
}
inline void IMAddFriendReq::set_addition_msg(const char* value) {
  set_has_addition_msg();
  if (addition_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    addition_msg_ = new ::std::string;
  }
  addition_msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAddFriendReq.addition_msg)
}
inline void IMAddFriendReq::set_addition_msg(const void* value, size_t size) {
  set_has_addition_msg();
  if (addition_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    addition_msg_ = new ::std::string;
  }
  addition_msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAddFriendReq.addition_msg)
}
inline ::std::string* IMAddFriendReq::mutable_addition_msg() {
  set_has_addition_msg();
  if (addition_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    addition_msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAddFriendReq.addition_msg)
  return addition_msg_;
}
inline ::std::string* IMAddFriendReq::release_addition_msg() {
  clear_has_addition_msg();
  if (addition_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = addition_msg_;
    addition_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAddFriendReq::set_allocated_addition_msg(::std::string* addition_msg) {
  if (addition_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete addition_msg_;
  }
  if (addition_msg) {
    set_has_addition_msg();
    addition_msg_ = addition_msg;
  } else {
    clear_has_addition_msg();
    addition_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAddFriendReq.addition_msg)
}

// optional bytes attach_data = 20;
inline bool IMAddFriendReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMAddFriendReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMAddFriendReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMAddFriendReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMAddFriendReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendReq.attach_data)
  return *attach_data_;
}
inline void IMAddFriendReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendReq.attach_data)
}
inline void IMAddFriendReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAddFriendReq.attach_data)
}
inline void IMAddFriendReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAddFriendReq.attach_data)
}
inline ::std::string* IMAddFriendReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAddFriendReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMAddFriendReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAddFriendReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAddFriendReq.attach_data)
}

// -------------------------------------------------------------------

// IMAddFriendRsp

// required uint32 user_id = 1;
inline bool IMAddFriendRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAddFriendRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAddFriendRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAddFriendRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMAddFriendRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendRsp.user_id)
  return user_id_;
}
inline void IMAddFriendRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendRsp.user_id)
}

// required uint32 friend_id = 2;
inline bool IMAddFriendRsp::has_friend_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAddFriendRsp::set_has_friend_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAddFriendRsp::clear_has_friend_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAddFriendRsp::clear_friend_id() {
  friend_id_ = 0u;
  clear_has_friend_id();
}
inline ::google::protobuf::uint32 IMAddFriendRsp::friend_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendRsp.friend_id)
  return friend_id_;
}
inline void IMAddFriendRsp::set_friend_id(::google::protobuf::uint32 value) {
  set_has_friend_id();
  friend_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendRsp.friend_id)
}

// required uint32 result_code = 3;
inline bool IMAddFriendRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMAddFriendRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMAddFriendRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMAddFriendRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMAddFriendRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendRsp.result_code)
  return result_code_;
}
inline void IMAddFriendRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendRsp.result_code)
}

// optional bytes add_friend_data = 4;
inline bool IMAddFriendRsp::has_add_friend_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMAddFriendRsp::set_has_add_friend_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMAddFriendRsp::clear_has_add_friend_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMAddFriendRsp::clear_add_friend_data() {
  if (add_friend_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    add_friend_data_->clear();
  }
  clear_has_add_friend_data();
}
inline const ::std::string& IMAddFriendRsp::add_friend_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendRsp.add_friend_data)
  return *add_friend_data_;
}
inline void IMAddFriendRsp::set_add_friend_data(const ::std::string& value) {
  set_has_add_friend_data();
  if (add_friend_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    add_friend_data_ = new ::std::string;
  }
  add_friend_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendRsp.add_friend_data)
}
inline void IMAddFriendRsp::set_add_friend_data(const char* value) {
  set_has_add_friend_data();
  if (add_friend_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    add_friend_data_ = new ::std::string;
  }
  add_friend_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAddFriendRsp.add_friend_data)
}
inline void IMAddFriendRsp::set_add_friend_data(const void* value, size_t size) {
  set_has_add_friend_data();
  if (add_friend_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    add_friend_data_ = new ::std::string;
  }
  add_friend_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAddFriendRsp.add_friend_data)
}
inline ::std::string* IMAddFriendRsp::mutable_add_friend_data() {
  set_has_add_friend_data();
  if (add_friend_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    add_friend_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAddFriendRsp.add_friend_data)
  return add_friend_data_;
}
inline ::std::string* IMAddFriendRsp::release_add_friend_data() {
  clear_has_add_friend_data();
  if (add_friend_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = add_friend_data_;
    add_friend_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAddFriendRsp::set_allocated_add_friend_data(::std::string* add_friend_data) {
  if (add_friend_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete add_friend_data_;
  }
  if (add_friend_data) {
    set_has_add_friend_data();
    add_friend_data_ = add_friend_data;
  } else {
    clear_has_add_friend_data();
    add_friend_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAddFriendRsp.add_friend_data)
}

// optional bytes attach_data = 20;
inline bool IMAddFriendRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMAddFriendRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMAddFriendRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMAddFriendRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMAddFriendRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendRsp.attach_data)
  return *attach_data_;
}
inline void IMAddFriendRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendRsp.attach_data)
}
inline void IMAddFriendRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAddFriendRsp.attach_data)
}
inline void IMAddFriendRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAddFriendRsp.attach_data)
}
inline ::std::string* IMAddFriendRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAddFriendRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMAddFriendRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAddFriendRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAddFriendRsp.attach_data)
}

// -------------------------------------------------------------------

// IMAddFriendData

// required uint32 user_id = 1;
inline bool IMAddFriendData::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAddFriendData::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAddFriendData::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAddFriendData::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMAddFriendData::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendData.user_id)
  return user_id_;
}
inline void IMAddFriendData::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendData.user_id)
}

// required uint32 friend_id = 2;
inline bool IMAddFriendData::has_friend_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAddFriendData::set_has_friend_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAddFriendData::clear_has_friend_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAddFriendData::clear_friend_id() {
  friend_id_ = 0u;
  clear_has_friend_id();
}
inline ::google::protobuf::uint32 IMAddFriendData::friend_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendData.friend_id)
  return friend_id_;
}
inline void IMAddFriendData::set_friend_id(::google::protobuf::uint32 value) {
  set_has_friend_id();
  friend_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendData.friend_id)
}

// required .IM.BaseDefine.SystemMsgType type = 3;
inline bool IMAddFriendData::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMAddFriendData::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMAddFriendData::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMAddFriendData::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::IM::BaseDefine::SystemMsgType IMAddFriendData::type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendData.type)
  return static_cast< ::IM::BaseDefine::SystemMsgType >(type_);
}
inline void IMAddFriendData::set_type(::IM::BaseDefine::SystemMsgType value) {
  assert(::IM::BaseDefine::SystemMsgType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendData.type)
}

// required bytes add_friend_data = 5;
inline bool IMAddFriendData::has_add_friend_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMAddFriendData::set_has_add_friend_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMAddFriendData::clear_has_add_friend_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMAddFriendData::clear_add_friend_data() {
  if (add_friend_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    add_friend_data_->clear();
  }
  clear_has_add_friend_data();
}
inline const ::std::string& IMAddFriendData::add_friend_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendData.add_friend_data)
  return *add_friend_data_;
}
inline void IMAddFriendData::set_add_friend_data(const ::std::string& value) {
  set_has_add_friend_data();
  if (add_friend_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    add_friend_data_ = new ::std::string;
  }
  add_friend_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendData.add_friend_data)
}
inline void IMAddFriendData::set_add_friend_data(const char* value) {
  set_has_add_friend_data();
  if (add_friend_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    add_friend_data_ = new ::std::string;
  }
  add_friend_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAddFriendData.add_friend_data)
}
inline void IMAddFriendData::set_add_friend_data(const void* value, size_t size) {
  set_has_add_friend_data();
  if (add_friend_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    add_friend_data_ = new ::std::string;
  }
  add_friend_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAddFriendData.add_friend_data)
}
inline ::std::string* IMAddFriendData::mutable_add_friend_data() {
  set_has_add_friend_data();
  if (add_friend_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    add_friend_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAddFriendData.add_friend_data)
  return add_friend_data_;
}
inline ::std::string* IMAddFriendData::release_add_friend_data() {
  clear_has_add_friend_data();
  if (add_friend_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = add_friend_data_;
    add_friend_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAddFriendData::set_allocated_add_friend_data(::std::string* add_friend_data) {
  if (add_friend_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete add_friend_data_;
  }
  if (add_friend_data) {
    set_has_add_friend_data();
    add_friend_data_ = add_friend_data;
  } else {
    clear_has_add_friend_data();
    add_friend_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAddFriendData.add_friend_data)
}

// optional bytes attach_data = 20;
inline bool IMAddFriendData::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMAddFriendData::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMAddFriendData::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMAddFriendData::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMAddFriendData::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendData.attach_data)
  return *attach_data_;
}
inline void IMAddFriendData::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendData.attach_data)
}
inline void IMAddFriendData::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAddFriendData.attach_data)
}
inline void IMAddFriendData::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAddFriendData.attach_data)
}
inline ::std::string* IMAddFriendData::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAddFriendData.attach_data)
  return attach_data_;
}
inline ::std::string* IMAddFriendData::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAddFriendData::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAddFriendData.attach_data)
}

// -------------------------------------------------------------------

// IMAddFriendReadDataAck

// required uint32 user_id = 1;
inline bool IMAddFriendReadDataAck::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAddFriendReadDataAck::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAddFriendReadDataAck::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAddFriendReadDataAck::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMAddFriendReadDataAck::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendReadDataAck.user_id)
  return user_id_;
}
inline void IMAddFriendReadDataAck::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendReadDataAck.user_id)
}

// optional bytes attach_data = 20;
inline bool IMAddFriendReadDataAck::has_attach_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAddFriendReadDataAck::set_has_attach_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAddFriendReadDataAck::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAddFriendReadDataAck::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMAddFriendReadDataAck::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendReadDataAck.attach_data)
  return *attach_data_;
}
inline void IMAddFriendReadDataAck::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendReadDataAck.attach_data)
}
inline void IMAddFriendReadDataAck::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAddFriendReadDataAck.attach_data)
}
inline void IMAddFriendReadDataAck::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAddFriendReadDataAck.attach_data)
}
inline ::std::string* IMAddFriendReadDataAck::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAddFriendReadDataAck.attach_data)
  return attach_data_;
}
inline ::std::string* IMAddFriendReadDataAck::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAddFriendReadDataAck::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAddFriendReadDataAck.attach_data)
}

// -------------------------------------------------------------------

// IMGetAddFriendDataReq

// required uint32 user_id = 1;
inline bool IMGetAddFriendDataReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMGetAddFriendDataReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMGetAddFriendDataReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMGetAddFriendDataReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMGetAddFriendDataReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMGetAddFriendDataReq.user_id)
  return user_id_;
}
inline void IMGetAddFriendDataReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMGetAddFriendDataReq.user_id)
}

// required uint32 msg_cnt = 2;
inline bool IMGetAddFriendDataReq::has_msg_cnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMGetAddFriendDataReq::set_has_msg_cnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMGetAddFriendDataReq::clear_has_msg_cnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMGetAddFriendDataReq::clear_msg_cnt() {
  msg_cnt_ = 0u;
  clear_has_msg_cnt();
}
inline ::google::protobuf::uint32 IMGetAddFriendDataReq::msg_cnt() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMGetAddFriendDataReq.msg_cnt)
  return msg_cnt_;
}
inline void IMGetAddFriendDataReq::set_msg_cnt(::google::protobuf::uint32 value) {
  set_has_msg_cnt();
  msg_cnt_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMGetAddFriendDataReq.msg_cnt)
}

// optional bytes attach_data = 20;
inline bool IMGetAddFriendDataReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMGetAddFriendDataReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMGetAddFriendDataReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMGetAddFriendDataReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMGetAddFriendDataReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMGetAddFriendDataReq.attach_data)
  return *attach_data_;
}
inline void IMGetAddFriendDataReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMGetAddFriendDataReq.attach_data)
}
inline void IMGetAddFriendDataReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMGetAddFriendDataReq.attach_data)
}
inline void IMGetAddFriendDataReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMGetAddFriendDataReq.attach_data)
}
inline ::std::string* IMGetAddFriendDataReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMGetAddFriendDataReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMGetAddFriendDataReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMGetAddFriendDataReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMGetAddFriendDataReq.attach_data)
}

// -------------------------------------------------------------------

// IMGetAddFriendDataRsp

// required uint32 user_id = 1;
inline bool IMGetAddFriendDataRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMGetAddFriendDataRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMGetAddFriendDataRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMGetAddFriendDataRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMGetAddFriendDataRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMGetAddFriendDataRsp.user_id)
  return user_id_;
}
inline void IMGetAddFriendDataRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMGetAddFriendDataRsp.user_id)
}

// repeated .IM.Buddy.IMAddFriendData data_list = 2;
inline int IMGetAddFriendDataRsp::data_list_size() const {
  return data_list_.size();
}
inline void IMGetAddFriendDataRsp::clear_data_list() {
  data_list_.Clear();
}
inline const ::IM::Buddy::IMAddFriendData& IMGetAddFriendDataRsp::data_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMGetAddFriendDataRsp.data_list)
  return data_list_.Get(index);
}
inline ::IM::Buddy::IMAddFriendData* IMGetAddFriendDataRsp::mutable_data_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMGetAddFriendDataRsp.data_list)
  return data_list_.Mutable(index);
}
inline ::IM::Buddy::IMAddFriendData* IMGetAddFriendDataRsp::add_data_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMGetAddFriendDataRsp.data_list)
  return data_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Buddy::IMAddFriendData >&
IMGetAddFriendDataRsp::data_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMGetAddFriendDataRsp.data_list)
  return data_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Buddy::IMAddFriendData >*
IMGetAddFriendDataRsp::mutable_data_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMGetAddFriendDataRsp.data_list)
  return &data_list_;
}

// optional bytes attach_data = 20;
inline bool IMGetAddFriendDataRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMGetAddFriendDataRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMGetAddFriendDataRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMGetAddFriendDataRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMGetAddFriendDataRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMGetAddFriendDataRsp.attach_data)
  return *attach_data_;
}
inline void IMGetAddFriendDataRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMGetAddFriendDataRsp.attach_data)
}
inline void IMGetAddFriendDataRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMGetAddFriendDataRsp.attach_data)
}
inline void IMGetAddFriendDataRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMGetAddFriendDataRsp.attach_data)
}
inline ::std::string* IMGetAddFriendDataRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMGetAddFriendDataRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMGetAddFriendDataRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMGetAddFriendDataRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMGetAddFriendDataRsp.attach_data)
}

// -------------------------------------------------------------------

// IMAddFriendUnreadCntReq

// required uint32 user_id = 1;
inline bool IMAddFriendUnreadCntReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAddFriendUnreadCntReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAddFriendUnreadCntReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAddFriendUnreadCntReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMAddFriendUnreadCntReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendUnreadCntReq.user_id)
  return user_id_;
}
inline void IMAddFriendUnreadCntReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendUnreadCntReq.user_id)
}

// optional bytes attach_data = 20;
inline bool IMAddFriendUnreadCntReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAddFriendUnreadCntReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAddFriendUnreadCntReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAddFriendUnreadCntReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMAddFriendUnreadCntReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendUnreadCntReq.attach_data)
  return *attach_data_;
}
inline void IMAddFriendUnreadCntReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendUnreadCntReq.attach_data)
}
inline void IMAddFriendUnreadCntReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAddFriendUnreadCntReq.attach_data)
}
inline void IMAddFriendUnreadCntReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAddFriendUnreadCntReq.attach_data)
}
inline ::std::string* IMAddFriendUnreadCntReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAddFriendUnreadCntReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMAddFriendUnreadCntReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAddFriendUnreadCntReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAddFriendUnreadCntReq.attach_data)
}

// -------------------------------------------------------------------

// IMAddFriendUnreadCntRsp

// required uint32 user_id = 1;
inline bool IMAddFriendUnreadCntRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAddFriendUnreadCntRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAddFriendUnreadCntRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAddFriendUnreadCntRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMAddFriendUnreadCntRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendUnreadCntRsp.user_id)
  return user_id_;
}
inline void IMAddFriendUnreadCntRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendUnreadCntRsp.user_id)
}

// required uint32 unread_cnt = 2;
inline bool IMAddFriendUnreadCntRsp::has_unread_cnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAddFriendUnreadCntRsp::set_has_unread_cnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAddFriendUnreadCntRsp::clear_has_unread_cnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAddFriendUnreadCntRsp::clear_unread_cnt() {
  unread_cnt_ = 0u;
  clear_has_unread_cnt();
}
inline ::google::protobuf::uint32 IMAddFriendUnreadCntRsp::unread_cnt() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendUnreadCntRsp.unread_cnt)
  return unread_cnt_;
}
inline void IMAddFriendUnreadCntRsp::set_unread_cnt(::google::protobuf::uint32 value) {
  set_has_unread_cnt();
  unread_cnt_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendUnreadCntRsp.unread_cnt)
}

// optional bytes attach_data = 20;
inline bool IMAddFriendUnreadCntRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMAddFriendUnreadCntRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMAddFriendUnreadCntRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMAddFriendUnreadCntRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMAddFriendUnreadCntRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAddFriendUnreadCntRsp.attach_data)
  return *attach_data_;
}
inline void IMAddFriendUnreadCntRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAddFriendUnreadCntRsp.attach_data)
}
inline void IMAddFriendUnreadCntRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAddFriendUnreadCntRsp.attach_data)
}
inline void IMAddFriendUnreadCntRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAddFriendUnreadCntRsp.attach_data)
}
inline ::std::string* IMAddFriendUnreadCntRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAddFriendUnreadCntRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMAddFriendUnreadCntRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAddFriendUnreadCntRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAddFriendUnreadCntRsp.attach_data)
}

// -------------------------------------------------------------------

// IMAgreeAddFriendReq

// required uint32 user_id = 1;
inline bool IMAgreeAddFriendReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAgreeAddFriendReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAgreeAddFriendReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAgreeAddFriendReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMAgreeAddFriendReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAgreeAddFriendReq.user_id)
  return user_id_;
}
inline void IMAgreeAddFriendReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAgreeAddFriendReq.user_id)
}

// required uint32 friend_id = 2;
inline bool IMAgreeAddFriendReq::has_friend_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAgreeAddFriendReq::set_has_friend_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAgreeAddFriendReq::clear_has_friend_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAgreeAddFriendReq::clear_friend_id() {
  friend_id_ = 0u;
  clear_has_friend_id();
}
inline ::google::protobuf::uint32 IMAgreeAddFriendReq::friend_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAgreeAddFriendReq.friend_id)
  return friend_id_;
}
inline void IMAgreeAddFriendReq::set_friend_id(::google::protobuf::uint32 value) {
  set_has_friend_id();
  friend_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAgreeAddFriendReq.friend_id)
}

// required .IM.BaseDefine.SystemMsgType agree = 3;
inline bool IMAgreeAddFriendReq::has_agree() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMAgreeAddFriendReq::set_has_agree() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMAgreeAddFriendReq::clear_has_agree() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMAgreeAddFriendReq::clear_agree() {
  agree_ = 1;
  clear_has_agree();
}
inline ::IM::BaseDefine::SystemMsgType IMAgreeAddFriendReq::agree() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAgreeAddFriendReq.agree)
  return static_cast< ::IM::BaseDefine::SystemMsgType >(agree_);
}
inline void IMAgreeAddFriendReq::set_agree(::IM::BaseDefine::SystemMsgType value) {
  assert(::IM::BaseDefine::SystemMsgType_IsValid(value));
  set_has_agree();
  agree_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAgreeAddFriendReq.agree)
}

// optional bytes addition_msg = 4;
inline bool IMAgreeAddFriendReq::has_addition_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMAgreeAddFriendReq::set_has_addition_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMAgreeAddFriendReq::clear_has_addition_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMAgreeAddFriendReq::clear_addition_msg() {
  if (addition_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    addition_msg_->clear();
  }
  clear_has_addition_msg();
}
inline const ::std::string& IMAgreeAddFriendReq::addition_msg() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAgreeAddFriendReq.addition_msg)
  return *addition_msg_;
}
inline void IMAgreeAddFriendReq::set_addition_msg(const ::std::string& value) {
  set_has_addition_msg();
  if (addition_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    addition_msg_ = new ::std::string;
  }
  addition_msg_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAgreeAddFriendReq.addition_msg)
}
inline void IMAgreeAddFriendReq::set_addition_msg(const char* value) {
  set_has_addition_msg();
  if (addition_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    addition_msg_ = new ::std::string;
  }
  addition_msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAgreeAddFriendReq.addition_msg)
}
inline void IMAgreeAddFriendReq::set_addition_msg(const void* value, size_t size) {
  set_has_addition_msg();
  if (addition_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    addition_msg_ = new ::std::string;
  }
  addition_msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAgreeAddFriendReq.addition_msg)
}
inline ::std::string* IMAgreeAddFriendReq::mutable_addition_msg() {
  set_has_addition_msg();
  if (addition_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    addition_msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAgreeAddFriendReq.addition_msg)
  return addition_msg_;
}
inline ::std::string* IMAgreeAddFriendReq::release_addition_msg() {
  clear_has_addition_msg();
  if (addition_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = addition_msg_;
    addition_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAgreeAddFriendReq::set_allocated_addition_msg(::std::string* addition_msg) {
  if (addition_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete addition_msg_;
  }
  if (addition_msg) {
    set_has_addition_msg();
    addition_msg_ = addition_msg;
  } else {
    clear_has_addition_msg();
    addition_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAgreeAddFriendReq.addition_msg)
}

// optional bytes attach_data = 20;
inline bool IMAgreeAddFriendReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMAgreeAddFriendReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMAgreeAddFriendReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMAgreeAddFriendReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMAgreeAddFriendReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAgreeAddFriendReq.attach_data)
  return *attach_data_;
}
inline void IMAgreeAddFriendReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAgreeAddFriendReq.attach_data)
}
inline void IMAgreeAddFriendReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAgreeAddFriendReq.attach_data)
}
inline void IMAgreeAddFriendReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAgreeAddFriendReq.attach_data)
}
inline ::std::string* IMAgreeAddFriendReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAgreeAddFriendReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMAgreeAddFriendReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAgreeAddFriendReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAgreeAddFriendReq.attach_data)
}

// -------------------------------------------------------------------

// IMAgreeAddFriendRsp

// required uint32 user_id = 1;
inline bool IMAgreeAddFriendRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAgreeAddFriendRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAgreeAddFriendRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAgreeAddFriendRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMAgreeAddFriendRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAgreeAddFriendRsp.user_id)
  return user_id_;
}
inline void IMAgreeAddFriendRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAgreeAddFriendRsp.user_id)
}

// required uint32 friend_id = 2;
inline bool IMAgreeAddFriendRsp::has_friend_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAgreeAddFriendRsp::set_has_friend_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAgreeAddFriendRsp::clear_has_friend_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAgreeAddFriendRsp::clear_friend_id() {
  friend_id_ = 0u;
  clear_has_friend_id();
}
inline ::google::protobuf::uint32 IMAgreeAddFriendRsp::friend_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAgreeAddFriendRsp.friend_id)
  return friend_id_;
}
inline void IMAgreeAddFriendRsp::set_friend_id(::google::protobuf::uint32 value) {
  set_has_friend_id();
  friend_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAgreeAddFriendRsp.friend_id)
}

// required .IM.BaseDefine.SystemMsgType agree = 3;
inline bool IMAgreeAddFriendRsp::has_agree() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMAgreeAddFriendRsp::set_has_agree() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMAgreeAddFriendRsp::clear_has_agree() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMAgreeAddFriendRsp::clear_agree() {
  agree_ = 1;
  clear_has_agree();
}
inline ::IM::BaseDefine::SystemMsgType IMAgreeAddFriendRsp::agree() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAgreeAddFriendRsp.agree)
  return static_cast< ::IM::BaseDefine::SystemMsgType >(agree_);
}
inline void IMAgreeAddFriendRsp::set_agree(::IM::BaseDefine::SystemMsgType value) {
  assert(::IM::BaseDefine::SystemMsgType_IsValid(value));
  set_has_agree();
  agree_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAgreeAddFriendRsp.agree)
}

// required uint32 result_code = 4;
inline bool IMAgreeAddFriendRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMAgreeAddFriendRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMAgreeAddFriendRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMAgreeAddFriendRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMAgreeAddFriendRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAgreeAddFriendRsp.result_code)
  return result_code_;
}
inline void IMAgreeAddFriendRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAgreeAddFriendRsp.result_code)
}

// optional bytes agree_friend_data = 5;
inline bool IMAgreeAddFriendRsp::has_agree_friend_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMAgreeAddFriendRsp::set_has_agree_friend_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMAgreeAddFriendRsp::clear_has_agree_friend_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMAgreeAddFriendRsp::clear_agree_friend_data() {
  if (agree_friend_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    agree_friend_data_->clear();
  }
  clear_has_agree_friend_data();
}
inline const ::std::string& IMAgreeAddFriendRsp::agree_friend_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAgreeAddFriendRsp.agree_friend_data)
  return *agree_friend_data_;
}
inline void IMAgreeAddFriendRsp::set_agree_friend_data(const ::std::string& value) {
  set_has_agree_friend_data();
  if (agree_friend_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    agree_friend_data_ = new ::std::string;
  }
  agree_friend_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAgreeAddFriendRsp.agree_friend_data)
}
inline void IMAgreeAddFriendRsp::set_agree_friend_data(const char* value) {
  set_has_agree_friend_data();
  if (agree_friend_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    agree_friend_data_ = new ::std::string;
  }
  agree_friend_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAgreeAddFriendRsp.agree_friend_data)
}
inline void IMAgreeAddFriendRsp::set_agree_friend_data(const void* value, size_t size) {
  set_has_agree_friend_data();
  if (agree_friend_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    agree_friend_data_ = new ::std::string;
  }
  agree_friend_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAgreeAddFriendRsp.agree_friend_data)
}
inline ::std::string* IMAgreeAddFriendRsp::mutable_agree_friend_data() {
  set_has_agree_friend_data();
  if (agree_friend_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    agree_friend_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAgreeAddFriendRsp.agree_friend_data)
  return agree_friend_data_;
}
inline ::std::string* IMAgreeAddFriendRsp::release_agree_friend_data() {
  clear_has_agree_friend_data();
  if (agree_friend_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = agree_friend_data_;
    agree_friend_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAgreeAddFriendRsp::set_allocated_agree_friend_data(::std::string* agree_friend_data) {
  if (agree_friend_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete agree_friend_data_;
  }
  if (agree_friend_data) {
    set_has_agree_friend_data();
    agree_friend_data_ = agree_friend_data;
  } else {
    clear_has_agree_friend_data();
    agree_friend_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAgreeAddFriendRsp.agree_friend_data)
}

// optional bytes attach_data = 20;
inline bool IMAgreeAddFriendRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMAgreeAddFriendRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMAgreeAddFriendRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMAgreeAddFriendRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMAgreeAddFriendRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAgreeAddFriendRsp.attach_data)
  return *attach_data_;
}
inline void IMAgreeAddFriendRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAgreeAddFriendRsp.attach_data)
}
inline void IMAgreeAddFriendRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAgreeAddFriendRsp.attach_data)
}
inline void IMAgreeAddFriendRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAgreeAddFriendRsp.attach_data)
}
inline ::std::string* IMAgreeAddFriendRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAgreeAddFriendRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMAgreeAddFriendRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAgreeAddFriendRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAgreeAddFriendRsp.attach_data)
}

// -------------------------------------------------------------------

// IMFollowUserReq

// required uint32 user_id = 1;
inline bool IMFollowUserReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFollowUserReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFollowUserReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFollowUserReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMFollowUserReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMFollowUserReq.user_id)
  return user_id_;
}
inline void IMFollowUserReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMFollowUserReq.user_id)
}

// required uint32 friend_id = 2;
inline bool IMFollowUserReq::has_friend_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFollowUserReq::set_has_friend_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFollowUserReq::clear_has_friend_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFollowUserReq::clear_friend_id() {
  friend_id_ = 0u;
  clear_has_friend_id();
}
inline ::google::protobuf::uint32 IMFollowUserReq::friend_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMFollowUserReq.friend_id)
  return friend_id_;
}
inline void IMFollowUserReq::set_friend_id(::google::protobuf::uint32 value) {
  set_has_friend_id();
  friend_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMFollowUserReq.friend_id)
}

// optional bytes attach_data = 20;
inline bool IMFollowUserReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFollowUserReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFollowUserReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFollowUserReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMFollowUserReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMFollowUserReq.attach_data)
  return *attach_data_;
}
inline void IMFollowUserReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMFollowUserReq.attach_data)
}
inline void IMFollowUserReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMFollowUserReq.attach_data)
}
inline void IMFollowUserReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMFollowUserReq.attach_data)
}
inline ::std::string* IMFollowUserReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMFollowUserReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMFollowUserReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMFollowUserReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMFollowUserReq.attach_data)
}

// -------------------------------------------------------------------

// IMFollowUserRsp

// required uint32 user_id = 1;
inline bool IMFollowUserRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFollowUserRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFollowUserRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFollowUserRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMFollowUserRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMFollowUserRsp.user_id)
  return user_id_;
}
inline void IMFollowUserRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMFollowUserRsp.user_id)
}

// required uint32 result_code = 2;
inline bool IMFollowUserRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFollowUserRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFollowUserRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFollowUserRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMFollowUserRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMFollowUserRsp.result_code)
  return result_code_;
}
inline void IMFollowUserRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMFollowUserRsp.result_code)
}

// optional bytes attach_data = 20;
inline bool IMFollowUserRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFollowUserRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFollowUserRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFollowUserRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMFollowUserRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMFollowUserRsp.attach_data)
  return *attach_data_;
}
inline void IMFollowUserRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMFollowUserRsp.attach_data)
}
inline void IMFollowUserRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMFollowUserRsp.attach_data)
}
inline void IMFollowUserRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMFollowUserRsp.attach_data)
}
inline ::std::string* IMFollowUserRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMFollowUserRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMFollowUserRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMFollowUserRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMFollowUserRsp.attach_data)
}

// -------------------------------------------------------------------

// IMDelFriendReq

// required uint32 user_id = 1;
inline bool IMDelFriendReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMDelFriendReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMDelFriendReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMDelFriendReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMDelFriendReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDelFriendReq.user_id)
  return user_id_;
}
inline void IMDelFriendReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDelFriendReq.user_id)
}

// required uint32 friend_id = 2;
inline bool IMDelFriendReq::has_friend_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMDelFriendReq::set_has_friend_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMDelFriendReq::clear_has_friend_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMDelFriendReq::clear_friend_id() {
  friend_id_ = 0u;
  clear_has_friend_id();
}
inline ::google::protobuf::uint32 IMDelFriendReq::friend_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDelFriendReq.friend_id)
  return friend_id_;
}
inline void IMDelFriendReq::set_friend_id(::google::protobuf::uint32 value) {
  set_has_friend_id();
  friend_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDelFriendReq.friend_id)
}

// optional bytes addition_msg = 3;
inline bool IMDelFriendReq::has_addition_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMDelFriendReq::set_has_addition_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMDelFriendReq::clear_has_addition_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMDelFriendReq::clear_addition_msg() {
  if (addition_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    addition_msg_->clear();
  }
  clear_has_addition_msg();
}
inline const ::std::string& IMDelFriendReq::addition_msg() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDelFriendReq.addition_msg)
  return *addition_msg_;
}
inline void IMDelFriendReq::set_addition_msg(const ::std::string& value) {
  set_has_addition_msg();
  if (addition_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    addition_msg_ = new ::std::string;
  }
  addition_msg_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDelFriendReq.addition_msg)
}
inline void IMDelFriendReq::set_addition_msg(const char* value) {
  set_has_addition_msg();
  if (addition_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    addition_msg_ = new ::std::string;
  }
  addition_msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMDelFriendReq.addition_msg)
}
inline void IMDelFriendReq::set_addition_msg(const void* value, size_t size) {
  set_has_addition_msg();
  if (addition_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    addition_msg_ = new ::std::string;
  }
  addition_msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMDelFriendReq.addition_msg)
}
inline ::std::string* IMDelFriendReq::mutable_addition_msg() {
  set_has_addition_msg();
  if (addition_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    addition_msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMDelFriendReq.addition_msg)
  return addition_msg_;
}
inline ::std::string* IMDelFriendReq::release_addition_msg() {
  clear_has_addition_msg();
  if (addition_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = addition_msg_;
    addition_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMDelFriendReq::set_allocated_addition_msg(::std::string* addition_msg) {
  if (addition_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete addition_msg_;
  }
  if (addition_msg) {
    set_has_addition_msg();
    addition_msg_ = addition_msg;
  } else {
    clear_has_addition_msg();
    addition_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMDelFriendReq.addition_msg)
}

// optional bytes attach_data = 20;
inline bool IMDelFriendReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMDelFriendReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMDelFriendReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMDelFriendReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMDelFriendReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDelFriendReq.attach_data)
  return *attach_data_;
}
inline void IMDelFriendReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDelFriendReq.attach_data)
}
inline void IMDelFriendReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMDelFriendReq.attach_data)
}
inline void IMDelFriendReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMDelFriendReq.attach_data)
}
inline ::std::string* IMDelFriendReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMDelFriendReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMDelFriendReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMDelFriendReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMDelFriendReq.attach_data)
}

// -------------------------------------------------------------------

// IMDelFriendRsp

// required uint32 user_id = 1;
inline bool IMDelFriendRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMDelFriendRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMDelFriendRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMDelFriendRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMDelFriendRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDelFriendRsp.user_id)
  return user_id_;
}
inline void IMDelFriendRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDelFriendRsp.user_id)
}

// required uint32 friend_id = 2;
inline bool IMDelFriendRsp::has_friend_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMDelFriendRsp::set_has_friend_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMDelFriendRsp::clear_has_friend_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMDelFriendRsp::clear_friend_id() {
  friend_id_ = 0u;
  clear_has_friend_id();
}
inline ::google::protobuf::uint32 IMDelFriendRsp::friend_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDelFriendRsp.friend_id)
  return friend_id_;
}
inline void IMDelFriendRsp::set_friend_id(::google::protobuf::uint32 value) {
  set_has_friend_id();
  friend_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDelFriendRsp.friend_id)
}

// required uint32 result_code = 3;
inline bool IMDelFriendRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMDelFriendRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMDelFriendRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMDelFriendRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMDelFriendRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDelFriendRsp.result_code)
  return result_code_;
}
inline void IMDelFriendRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDelFriendRsp.result_code)
}

// optional bytes addition_msg = 4;
inline bool IMDelFriendRsp::has_addition_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMDelFriendRsp::set_has_addition_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMDelFriendRsp::clear_has_addition_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMDelFriendRsp::clear_addition_msg() {
  if (addition_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    addition_msg_->clear();
  }
  clear_has_addition_msg();
}
inline const ::std::string& IMDelFriendRsp::addition_msg() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDelFriendRsp.addition_msg)
  return *addition_msg_;
}
inline void IMDelFriendRsp::set_addition_msg(const ::std::string& value) {
  set_has_addition_msg();
  if (addition_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    addition_msg_ = new ::std::string;
  }
  addition_msg_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDelFriendRsp.addition_msg)
}
inline void IMDelFriendRsp::set_addition_msg(const char* value) {
  set_has_addition_msg();
  if (addition_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    addition_msg_ = new ::std::string;
  }
  addition_msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMDelFriendRsp.addition_msg)
}
inline void IMDelFriendRsp::set_addition_msg(const void* value, size_t size) {
  set_has_addition_msg();
  if (addition_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    addition_msg_ = new ::std::string;
  }
  addition_msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMDelFriendRsp.addition_msg)
}
inline ::std::string* IMDelFriendRsp::mutable_addition_msg() {
  set_has_addition_msg();
  if (addition_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    addition_msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMDelFriendRsp.addition_msg)
  return addition_msg_;
}
inline ::std::string* IMDelFriendRsp::release_addition_msg() {
  clear_has_addition_msg();
  if (addition_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = addition_msg_;
    addition_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMDelFriendRsp::set_allocated_addition_msg(::std::string* addition_msg) {
  if (addition_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete addition_msg_;
  }
  if (addition_msg) {
    set_has_addition_msg();
    addition_msg_ = addition_msg;
  } else {
    clear_has_addition_msg();
    addition_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMDelFriendRsp.addition_msg)
}

// optional bytes attach_data = 20;
inline bool IMDelFriendRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMDelFriendRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMDelFriendRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMDelFriendRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMDelFriendRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDelFriendRsp.attach_data)
  return *attach_data_;
}
inline void IMDelFriendRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDelFriendRsp.attach_data)
}
inline void IMDelFriendRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMDelFriendRsp.attach_data)
}
inline void IMDelFriendRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMDelFriendRsp.attach_data)
}
inline ::std::string* IMDelFriendRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMDelFriendRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMDelFriendRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMDelFriendRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMDelFriendRsp.attach_data)
}

// -------------------------------------------------------------------

// IMDelFollowUserReq

// required uint32 user_id = 1;
inline bool IMDelFollowUserReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMDelFollowUserReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMDelFollowUserReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMDelFollowUserReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMDelFollowUserReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDelFollowUserReq.user_id)
  return user_id_;
}
inline void IMDelFollowUserReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDelFollowUserReq.user_id)
}

// required uint32 friend_id = 2;
inline bool IMDelFollowUserReq::has_friend_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMDelFollowUserReq::set_has_friend_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMDelFollowUserReq::clear_has_friend_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMDelFollowUserReq::clear_friend_id() {
  friend_id_ = 0u;
  clear_has_friend_id();
}
inline ::google::protobuf::uint32 IMDelFollowUserReq::friend_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDelFollowUserReq.friend_id)
  return friend_id_;
}
inline void IMDelFollowUserReq::set_friend_id(::google::protobuf::uint32 value) {
  set_has_friend_id();
  friend_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDelFollowUserReq.friend_id)
}

// optional bytes attach_data = 20;
inline bool IMDelFollowUserReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMDelFollowUserReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMDelFollowUserReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMDelFollowUserReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMDelFollowUserReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDelFollowUserReq.attach_data)
  return *attach_data_;
}
inline void IMDelFollowUserReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDelFollowUserReq.attach_data)
}
inline void IMDelFollowUserReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMDelFollowUserReq.attach_data)
}
inline void IMDelFollowUserReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMDelFollowUserReq.attach_data)
}
inline ::std::string* IMDelFollowUserReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMDelFollowUserReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMDelFollowUserReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMDelFollowUserReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMDelFollowUserReq.attach_data)
}

// -------------------------------------------------------------------

// IMDelFollowUserRsp

// required uint32 user_id = 1;
inline bool IMDelFollowUserRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMDelFollowUserRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMDelFollowUserRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMDelFollowUserRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMDelFollowUserRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDelFollowUserRsp.user_id)
  return user_id_;
}
inline void IMDelFollowUserRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDelFollowUserRsp.user_id)
}

// required uint32 friend_id = 2;
inline bool IMDelFollowUserRsp::has_friend_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMDelFollowUserRsp::set_has_friend_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMDelFollowUserRsp::clear_has_friend_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMDelFollowUserRsp::clear_friend_id() {
  friend_id_ = 0u;
  clear_has_friend_id();
}
inline ::google::protobuf::uint32 IMDelFollowUserRsp::friend_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDelFollowUserRsp.friend_id)
  return friend_id_;
}
inline void IMDelFollowUserRsp::set_friend_id(::google::protobuf::uint32 value) {
  set_has_friend_id();
  friend_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDelFollowUserRsp.friend_id)
}

// required uint32 result_code = 3;
inline bool IMDelFollowUserRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMDelFollowUserRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMDelFollowUserRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMDelFollowUserRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMDelFollowUserRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDelFollowUserRsp.result_code)
  return result_code_;
}
inline void IMDelFollowUserRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDelFollowUserRsp.result_code)
}

// optional bytes attach_data = 20;
inline bool IMDelFollowUserRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMDelFollowUserRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMDelFollowUserRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMDelFollowUserRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMDelFollowUserRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDelFollowUserRsp.attach_data)
  return *attach_data_;
}
inline void IMDelFollowUserRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDelFollowUserRsp.attach_data)
}
inline void IMDelFollowUserRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMDelFollowUserRsp.attach_data)
}
inline void IMDelFollowUserRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMDelFollowUserRsp.attach_data)
}
inline ::std::string* IMDelFollowUserRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMDelFollowUserRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMDelFollowUserRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMDelFollowUserRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMDelFollowUserRsp.attach_data)
}

// -------------------------------------------------------------------

// IMALLOnlineUserCntReq

// required uint32 user_id = 1;
inline bool IMALLOnlineUserCntReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMALLOnlineUserCntReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMALLOnlineUserCntReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMALLOnlineUserCntReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMALLOnlineUserCntReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMALLOnlineUserCntReq.user_id)
  return user_id_;
}
inline void IMALLOnlineUserCntReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMALLOnlineUserCntReq.user_id)
}

// optional bytes attach_data = 20;
inline bool IMALLOnlineUserCntReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMALLOnlineUserCntReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMALLOnlineUserCntReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMALLOnlineUserCntReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMALLOnlineUserCntReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMALLOnlineUserCntReq.attach_data)
  return *attach_data_;
}
inline void IMALLOnlineUserCntReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMALLOnlineUserCntReq.attach_data)
}
inline void IMALLOnlineUserCntReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMALLOnlineUserCntReq.attach_data)
}
inline void IMALLOnlineUserCntReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMALLOnlineUserCntReq.attach_data)
}
inline ::std::string* IMALLOnlineUserCntReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMALLOnlineUserCntReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMALLOnlineUserCntReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMALLOnlineUserCntReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMALLOnlineUserCntReq.attach_data)
}

// -------------------------------------------------------------------

// IMALLOnlineUserCntRsp

// required uint32 user_id = 1;
inline bool IMALLOnlineUserCntRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMALLOnlineUserCntRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMALLOnlineUserCntRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMALLOnlineUserCntRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMALLOnlineUserCntRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMALLOnlineUserCntRsp.user_id)
  return user_id_;
}
inline void IMALLOnlineUserCntRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMALLOnlineUserCntRsp.user_id)
}

// required uint32 online_user_cnt = 2;
inline bool IMALLOnlineUserCntRsp::has_online_user_cnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMALLOnlineUserCntRsp::set_has_online_user_cnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMALLOnlineUserCntRsp::clear_has_online_user_cnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMALLOnlineUserCntRsp::clear_online_user_cnt() {
  online_user_cnt_ = 0u;
  clear_has_online_user_cnt();
}
inline ::google::protobuf::uint32 IMALLOnlineUserCntRsp::online_user_cnt() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMALLOnlineUserCntRsp.online_user_cnt)
  return online_user_cnt_;
}
inline void IMALLOnlineUserCntRsp::set_online_user_cnt(::google::protobuf::uint32 value) {
  set_has_online_user_cnt();
  online_user_cnt_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMALLOnlineUserCntRsp.online_user_cnt)
}

// optional bytes attach_data = 20;
inline bool IMALLOnlineUserCntRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMALLOnlineUserCntRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMALLOnlineUserCntRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMALLOnlineUserCntRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMALLOnlineUserCntRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMALLOnlineUserCntRsp.attach_data)
  return *attach_data_;
}
inline void IMALLOnlineUserCntRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMALLOnlineUserCntRsp.attach_data)
}
inline void IMALLOnlineUserCntRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMALLOnlineUserCntRsp.attach_data)
}
inline void IMALLOnlineUserCntRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMALLOnlineUserCntRsp.attach_data)
}
inline ::std::string* IMALLOnlineUserCntRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMALLOnlineUserCntRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMALLOnlineUserCntRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMALLOnlineUserCntRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMALLOnlineUserCntRsp.attach_data)
}

// -------------------------------------------------------------------

// IMUpdateUsersInfoReq

// required uint32 user_id = 1;
inline bool IMUpdateUsersInfoReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUpdateUsersInfoReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUpdateUsersInfoReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUpdateUsersInfoReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUpdateUsersInfoReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUpdateUsersInfoReq.user_id)
  return user_id_;
}
inline void IMUpdateUsersInfoReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUpdateUsersInfoReq.user_id)
}

// required .IM.BaseDefine.UserInfo user_info = 2;
inline bool IMUpdateUsersInfoReq::has_user_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMUpdateUsersInfoReq::set_has_user_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMUpdateUsersInfoReq::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMUpdateUsersInfoReq::clear_user_info() {
  if (user_info_ != NULL) user_info_->::IM::BaseDefine::UserInfo::Clear();
  clear_has_user_info();
}
inline const ::IM::BaseDefine::UserInfo& IMUpdateUsersInfoReq::user_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUpdateUsersInfoReq.user_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_info_ != NULL ? *user_info_ : *default_instance().user_info_;
#else
  return user_info_ != NULL ? *user_info_ : *default_instance_->user_info_;
#endif
}
inline ::IM::BaseDefine::UserInfo* IMUpdateUsersInfoReq::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) user_info_ = new ::IM::BaseDefine::UserInfo;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUpdateUsersInfoReq.user_info)
  return user_info_;
}
inline ::IM::BaseDefine::UserInfo* IMUpdateUsersInfoReq::release_user_info() {
  clear_has_user_info();
  ::IM::BaseDefine::UserInfo* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline void IMUpdateUsersInfoReq::set_allocated_user_info(::IM::BaseDefine::UserInfo* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUpdateUsersInfoReq.user_info)
}

// optional bytes attach_data = 20;
inline bool IMUpdateUsersInfoReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUpdateUsersInfoReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUpdateUsersInfoReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUpdateUsersInfoReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUpdateUsersInfoReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUpdateUsersInfoReq.attach_data)
  return *attach_data_;
}
inline void IMUpdateUsersInfoReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUpdateUsersInfoReq.attach_data)
}
inline void IMUpdateUsersInfoReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUpdateUsersInfoReq.attach_data)
}
inline void IMUpdateUsersInfoReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUpdateUsersInfoReq.attach_data)
}
inline ::std::string* IMUpdateUsersInfoReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUpdateUsersInfoReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMUpdateUsersInfoReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUpdateUsersInfoReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUpdateUsersInfoReq.attach_data)
}

// -------------------------------------------------------------------

// IMUpdateUsersInfoRsp

// required uint32 user_id = 1;
inline bool IMUpdateUsersInfoRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUpdateUsersInfoRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUpdateUsersInfoRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUpdateUsersInfoRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUpdateUsersInfoRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUpdateUsersInfoRsp.user_id)
  return user_id_;
}
inline void IMUpdateUsersInfoRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUpdateUsersInfoRsp.user_id)
}

// required uint32 result_code = 2;
inline bool IMUpdateUsersInfoRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMUpdateUsersInfoRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMUpdateUsersInfoRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMUpdateUsersInfoRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMUpdateUsersInfoRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUpdateUsersInfoRsp.result_code)
  return result_code_;
}
inline void IMUpdateUsersInfoRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUpdateUsersInfoRsp.result_code)
}

// optional bytes attach_data = 20;
inline bool IMUpdateUsersInfoRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUpdateUsersInfoRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUpdateUsersInfoRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUpdateUsersInfoRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUpdateUsersInfoRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUpdateUsersInfoRsp.attach_data)
  return *attach_data_;
}
inline void IMUpdateUsersInfoRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUpdateUsersInfoRsp.attach_data)
}
inline void IMUpdateUsersInfoRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUpdateUsersInfoRsp.attach_data)
}
inline void IMUpdateUsersInfoRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUpdateUsersInfoRsp.attach_data)
}
inline ::std::string* IMUpdateUsersInfoRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUpdateUsersInfoRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMUpdateUsersInfoRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUpdateUsersInfoRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUpdateUsersInfoRsp.attach_data)
}

// -------------------------------------------------------------------

// IMRecommendListReq

// required uint32 user_id = 1;
inline bool IMRecommendListReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRecommendListReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRecommendListReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRecommendListReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRecommendListReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecommendListReq.user_id)
  return user_id_;
}
inline void IMRecommendListReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecommendListReq.user_id)
}

// required uint32 page = 2;
inline bool IMRecommendListReq::has_page() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRecommendListReq::set_has_page() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRecommendListReq::clear_has_page() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRecommendListReq::clear_page() {
  page_ = 0u;
  clear_has_page();
}
inline ::google::protobuf::uint32 IMRecommendListReq::page() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecommendListReq.page)
  return page_;
}
inline void IMRecommendListReq::set_page(::google::protobuf::uint32 value) {
  set_has_page();
  page_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecommendListReq.page)
}

// required uint32 page_size = 3;
inline bool IMRecommendListReq::has_page_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRecommendListReq::set_has_page_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRecommendListReq::clear_has_page_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRecommendListReq::clear_page_size() {
  page_size_ = 0u;
  clear_has_page_size();
}
inline ::google::protobuf::uint32 IMRecommendListReq::page_size() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecommendListReq.page_size)
  return page_size_;
}
inline void IMRecommendListReq::set_page_size(::google::protobuf::uint32 value) {
  set_has_page_size();
  page_size_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecommendListReq.page_size)
}

// optional bytes attach_data = 20;
inline bool IMRecommendListReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMRecommendListReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMRecommendListReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMRecommendListReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRecommendListReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecommendListReq.attach_data)
  return *attach_data_;
}
inline void IMRecommendListReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecommendListReq.attach_data)
}
inline void IMRecommendListReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMRecommendListReq.attach_data)
}
inline void IMRecommendListReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMRecommendListReq.attach_data)
}
inline ::std::string* IMRecommendListReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRecommendListReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMRecommendListReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRecommendListReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMRecommendListReq.attach_data)
}

// -------------------------------------------------------------------

// IMRecommendListRsp

// repeated uint32 recommend_list = 1;
inline int IMRecommendListRsp::recommend_list_size() const {
  return recommend_list_.size();
}
inline void IMRecommendListRsp::clear_recommend_list() {
  recommend_list_.Clear();
}
inline ::google::protobuf::uint32 IMRecommendListRsp::recommend_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecommendListRsp.recommend_list)
  return recommend_list_.Get(index);
}
inline void IMRecommendListRsp::set_recommend_list(int index, ::google::protobuf::uint32 value) {
  recommend_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecommendListRsp.recommend_list)
}
inline void IMRecommendListRsp::add_recommend_list(::google::protobuf::uint32 value) {
  recommend_list_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Buddy.IMRecommendListRsp.recommend_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMRecommendListRsp::recommend_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMRecommendListRsp.recommend_list)
  return recommend_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMRecommendListRsp::mutable_recommend_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMRecommendListRsp.recommend_list)
  return &recommend_list_;
}

// repeated string recommend_nick_list = 2;
inline int IMRecommendListRsp::recommend_nick_list_size() const {
  return recommend_nick_list_.size();
}
inline void IMRecommendListRsp::clear_recommend_nick_list() {
  recommend_nick_list_.Clear();
}
inline const ::std::string& IMRecommendListRsp::recommend_nick_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecommendListRsp.recommend_nick_list)
  return recommend_nick_list_.Get(index);
}
inline ::std::string* IMRecommendListRsp::mutable_recommend_nick_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRecommendListRsp.recommend_nick_list)
  return recommend_nick_list_.Mutable(index);
}
inline void IMRecommendListRsp::set_recommend_nick_list(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecommendListRsp.recommend_nick_list)
  recommend_nick_list_.Mutable(index)->assign(value);
}
inline void IMRecommendListRsp::set_recommend_nick_list(int index, const char* value) {
  recommend_nick_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMRecommendListRsp.recommend_nick_list)
}
inline void IMRecommendListRsp::set_recommend_nick_list(int index, const char* value, size_t size) {
  recommend_nick_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMRecommendListRsp.recommend_nick_list)
}
inline ::std::string* IMRecommendListRsp::add_recommend_nick_list() {
  return recommend_nick_list_.Add();
}
inline void IMRecommendListRsp::add_recommend_nick_list(const ::std::string& value) {
  recommend_nick_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:IM.Buddy.IMRecommendListRsp.recommend_nick_list)
}
inline void IMRecommendListRsp::add_recommend_nick_list(const char* value) {
  recommend_nick_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:IM.Buddy.IMRecommendListRsp.recommend_nick_list)
}
inline void IMRecommendListRsp::add_recommend_nick_list(const char* value, size_t size) {
  recommend_nick_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:IM.Buddy.IMRecommendListRsp.recommend_nick_list)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IMRecommendListRsp::recommend_nick_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMRecommendListRsp.recommend_nick_list)
  return recommend_nick_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IMRecommendListRsp::mutable_recommend_nick_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMRecommendListRsp.recommend_nick_list)
  return &recommend_nick_list_;
}

// optional bytes attach_data = 20;
inline bool IMRecommendListRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRecommendListRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRecommendListRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRecommendListRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRecommendListRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecommendListRsp.attach_data)
  return *attach_data_;
}
inline void IMRecommendListRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecommendListRsp.attach_data)
}
inline void IMRecommendListRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMRecommendListRsp.attach_data)
}
inline void IMRecommendListRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMRecommendListRsp.attach_data)
}
inline ::std::string* IMRecommendListRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRecommendListRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMRecommendListRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRecommendListRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMRecommendListRsp.attach_data)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Buddy
}  // namespace IM

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IM_2eBuddy_2eproto__INCLUDED
